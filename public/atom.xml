<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marsen</title>
  <icon>https://www.gravatar.com/avatar/be6152866ede00bca9d8f92aa352c938</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.marsen.me/"/>
  <updated>2018-04-17T03:36:43.312Z</updated>
  <id>http://blog.marsen.me/</id>
  
  <author>
    <name>Marsen L.</name>
    <email>thisismysoul@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[實作筆記]重灌開發環境</title>
    <link href="http://blog.marsen.me/2018/04/17/2018/new_pc_install/"/>
    <id>http://blog.marsen.me/2018/04/17/2018/new_pc_install/</id>
    <published>2018-04-17T03:34:51.000Z</published>
    <updated>2018-04-17T03:36:43.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Typescript-踩雷"><a href="#1-Typescript-踩雷" class="headerlink" title="1.Typescript 踩雷"></a>1.Typescript 踩雷</h2><h4 id="問題"><a href="#問題" class="headerlink" title="問題:"></a>問題:</h4><p>visual studio 預設會安裝 typescript 2.6<br>專案使用 typescript 2.3 , 因為暫時無法升級到2.6以上的版本<br>會導致專案無法編譯成功</p><h4 id="解決步驟"><a href="#解決步驟" class="headerlink" title="解決步驟"></a>解決步驟</h4><ol><li>在專案目錄執行 <code>npm i</code> 重新安裝相關module</li><li>complie 後發現 <code>node_modules/@types</code> 中有檔案無法成功編譯</li><li>移除 <code>node_modules/@types</code> 整個資料夾</li><li>重新 complie 後仍會無法成功</li><li>移除 <code>C:\Program Files (x86)\Microsoft SDKs\TypeScript\2.6</code> (非必要,好像要看vs預設載入的版本為何?)</li></ol><h2 id="2-多語系dll衝突"><a href="#2-多語系dll衝突" class="headerlink" title="2.多語系dll衝突"></a>2.多語系dll衝突</h2><ol><li>清空<code>bin</code>資料夾</li><li>清空 <code>c:\Windows\Microsoft.NET\Framework64\v4.0.30319\Temporary ASP.NET Files\</code>資料夾</li><li>重建前台專案</li></ol><h2 id="3-Chocolatey"><a href="#3-Chocolatey" class="headerlink" title="3.Chocolatey"></a>3.Chocolatey</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">choco install googlechrome -y</span><br><span class="line">choco install dropbox -y</span><br><span class="line">choco install evernote -y</span><br><span class="line"></span><br><span class="line">choco install git -y</span><br><span class="line">choco install nodejs -y</span><br><span class="line">choco install putty -y</span><br><span class="line">choco install visualstudiocode -y</span><br><span class="line"></span><br><span class="line">choco install winmerge -y</span><br><span class="line">choco install slack -y</span><br><span class="line">choco install linqpad -y</span><br><span class="line">choco install 7zip -y</span><br><span class="line"> </span><br><span class="line">choco install gitkraken -y</span><br><span class="line"><span class="meta">#</span>choco install sourcetree -y</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Typescript-踩雷&quot;&gt;&lt;a href=&quot;#1-Typescript-踩雷&quot; class=&quot;headerlink&quot; title=&quot;1.Typescript 踩雷&quot;&gt;&lt;/a&gt;1.Typescript 踩雷&lt;/h2&gt;&lt;h4 id=&quot;問題&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[學習筆記]允許 IAM User 存取 AWS Billing Console</title>
    <link href="http://blog.marsen.me/2018/04/04/cloud_learn/aws_access_billing_console/"/>
    <id>http://blog.marsen.me/2018/04/04/cloud_learn/aws_access_billing_console/</id>
    <published>2018-04-04T09:08:44.000Z</published>
    <updated>2018-04-17T03:12:39.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>設定了 IAM User Account 也給予了 Administrator 的權限,<br>不過仍然看不到 Billing 的頁面資訊 .  </p><p><img src="https://i.imgur.com/1Ge6pGi.jpg" alt=""></p><p>這帶來了很大的不方便, 因為如果要看 Billing 的資訊就要切換到 Root Account<br>而建立 Administrator IAM Account 的用意本來就是要儘可能不使用 Root Account 作登入.<br>檢查了權限,明明就有設定 Read Billing 但是仍然看不到.  </p><h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>實際上要進入 Billing Console 其實要有兩個步驟  </p><ol><li>權限要設定,更多細節可以參考這篇<a href="https://aws.amazon.com/blogs/security/enhanced-iam-capabilities-for-the-aws-billing-console/" target="_blank" rel="noopener">文章</a>(2014)</li><li>要透過 Root Account 在 <a href="https://console.aws.amazon.com/billing/home#/account" target="_blank" rel="noopener">Account Settings</a> 頁面設定, 允許 IAM user 存取 Billing Console  </li></ol><p><img src="https://i.imgur.com/yBXaLPJ.jpg" alt=""></p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://aws.amazon.com/blogs/security/dont-forget-to-enable-access-to-the-billing-console/" target="_blank" rel="noopener">Don’t Forget to Enable Access to the Billing Console!</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;設定了 IAM User Account 也給予了 Administrator 的權限,&lt;br&gt;不過仍然看不到 Billin
      
    
    </summary>
    
    
      <category term="AWS" scheme="http://blog.marsen.me/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>[學習筆記] Linux 語法學習筆記 一</title>
    <link href="http://blog.marsen.me/2018/03/26/2018/linux_command_1/"/>
    <id>http://blog.marsen.me/2018/03/26/2018/linux_command_1/</id>
    <published>2018-03-25T16:23:01.000Z</published>
    <updated>2018-04-17T03:12:39.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://www.tutorialspoint.com/unix_terminal_online.php" target="_blank" rel="noopener">Unix Terminal Online</a></li><li><a href="https://www.udemy.com/learn-shell-scripting-all-levels/" target="_blank" rel="noopener">Learn Shell Scripting all Levels</a></li><li><a href="http://linux.vbird.org/linux_basic/0320bash/csh/no3-8-01.html" target="_blank" rel="noopener">umask 指令</a></li></ul><h2 id="學習筆記"><a href="#學習筆記" class="headerlink" title="學習筆記"></a>學習筆記</h2><h3 id="Clear"><a href="#Clear" class="headerlink" title="Clear"></a><code>Clear</code></h3><h4 id="清除目前-terminal-畫面"><a href="#清除目前-terminal-畫面" class="headerlink" title="清除目前 terminal 畫面"></a>清除目前 terminal 畫面</h4><h3 id="Cal"><a href="#Cal" class="headerlink" title="Cal"></a><code>Cal</code></h3><h4 id="產生當下的月曆"><a href="#產生當下的月曆" class="headerlink" title="產生當下的月曆"></a>產生當下的月曆</h4><blockquote><p>$ cal                                                </p></blockquote><blockquote><p>March 2018<br>Su Mo Tu We Th Fr Sa<br>             1  2  3<br> 4  5  6  7  8  9 10<br>11 12 13 14 15 16 17<br>18 19 20 21 22 23 24<br>25 26 27 28 29 30 31</p></blockquote><blockquote><p>$ cal 2 1985</p></blockquote><blockquote><p>   February 1985<br>Su Mo Tu We Th Fr Sa<br>                1  2<br> 3  4  5  6  7  8  9<br>10 11 12 13 14 15 16<br>17 18 19 20 21 22 23<br>24 25 26 27 28 </p></blockquote><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a><code>Date</code></h3><h4 id="顯示日期與時間"><a href="#顯示日期與時間" class="headerlink" title="顯示日期與時間"></a>顯示日期與時間</h4><blockquote><p>$ date</p></blockquote><blockquote><p>Sat Mar 10 19:01:37 UTC 2018</p></blockquote><blockquote><p>$ date  ‘+ %y-%m-%d %n %H:%M:%S:%N’</p></blockquote><blockquote><p>18-03-10<br>19:06:24:126172657</p></blockquote><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a><code>pwd</code></h3><h4 id="目前所在的檔案路徑"><a href="#目前所在的檔案路徑" class="headerlink" title="目前所在的檔案路徑"></a>目前所在的檔案路徑</h4><h3 id="Touch"><a href="#Touch" class="headerlink" title="Touch"></a><code>Touch</code></h3><h4 id="建立檔案"><a href="#建立檔案" class="headerlink" title="建立檔案"></a>建立檔案</h4><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a><code>mkdir</code></h3><h4 id="建立資料夾"><a href="#建立資料夾" class="headerlink" title="建立資料夾"></a>建立資料夾</h4><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a><code>cat</code></h3><h4 id="寫檔案-cat-gt-filename"><a href="#寫檔案-cat-gt-filename" class="headerlink" title="寫檔案 cat &gt; filename"></a>寫檔案 <code>cat &gt; filename</code></h4><blockquote><p>ctrl + d 可以離開編輯</p></blockquote><h4 id="讀檔案-cat-lt-filename"><a href="#讀檔案-cat-lt-filename" class="headerlink" title="讀檔案 cat &lt; filename"></a>讀檔案 <code>cat &lt; filename</code></h4><h4 id="合併檔案-cat-file1-file2-gt-merged-file"><a href="#合併檔案-cat-file1-file2-gt-merged-file" class="headerlink" title="合併檔案 cat file1 file2 &gt; merged_file"></a>合併檔案 <code>cat file1 file2 &gt; merged_file</code></h4><blockquote><p>$ cat &gt; file1<br>this is file1<br>$ cat file1<br>this is file1<br>$ cat &gt; file2<br>this is file2<br>$ cat file2<br>this is file2<br>$ cat file1 file2 &gt; merged_file<br>$ cat merged_file<br>this is file1<br>this is file2</p></blockquote><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a><code>mv</code></h3><h4 id="重新命名檔案"><a href="#重新命名檔案" class="headerlink" title="重新命名檔案"></a>重新命名檔案</h4><blockquote><p>mv origin_name new_name</p></blockquote><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h3><h4 id="刪除檔案或資料夾"><a href="#刪除檔案或資料夾" class="headerlink" title="刪除檔案或資料夾"></a>刪除檔案或資料夾</h4><blockquote><p>$ rm file_name</p></blockquote><blockquote><p>$ rm -r folder_name/</p></blockquote><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a><code>rmdir</code></h3><h4 id="刪除資料夾"><a href="#刪除資料夾" class="headerlink" title="刪除資料夾"></a>刪除資料夾</h4><blockquote><p>$ rmdir folder_name/</p></blockquote><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a><code>cp</code></h3><h4 id="複製檔案"><a href="#複製檔案" class="headerlink" title="複製檔案"></a>複製檔案</h4><blockquote><p>$ cp oldfile other_folder/newfile</p></blockquote><h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a><code>ln</code></h3><h4 id="聯結檔案-hard-link"><a href="#聯結檔案-hard-link" class="headerlink" title="聯結檔案(hard link)"></a>聯結檔案(hard link)</h4><blockquote><p>$ touch one<br>$ cat &lt; one<br>$ ln one two<br>$ ls<br>one  two<br>$ cat &gt; one<br>this is one<br>$ cat &lt; one<br>this is one<br>$ cat &lt; two<br>this is one                                            </p></blockquote><h4 id="ln-s-soft-link"><a href="#ln-s-soft-link" class="headerlink" title="ln -s soft link"></a><code>ln -s</code> soft link</h4><p>hard link 會產生實體檔案,soft link只是指標的轉向.<br>如果使用soft link,當刪除原始檔案時,link檔案將無法開啟.</p><h3 id="檔案權限概觀"><a href="#檔案權限概觀" class="headerlink" title="檔案權限概觀"></a>檔案權限概觀</h3><h4 id="三種權限"><a href="#三種權限" class="headerlink" title="三種權限"></a>三種權限</h4><ul><li>read / 讀 / 100 =&gt; 4</li><li>write / 寫 / 010 =&gt; 2</li><li>execute / 執行 / 001 =&gt; 1</li></ul><p>每個權限都有一個代號,<br>read 表示可讀權限, 意味著可以開啟檔案與看見內容,<br>代號為4,二進位表示為100<br>write 表示可以複寫其內容,<br>代號為2,二進位表示為010,<br>execute 代表可執行,適用可執行檔或shell script,<br>代號為1,二進位表示為001.<br>三種權限都有的話,權限為(111=&gt;7)</p><h4 id="三種身份"><a href="#三種身份" class="headerlink" title="三種身份"></a>三種身份</h4><ul><li>owner 開啟的帳號</li><li>owner group 開啟的帳號所屬的群組</li><li>other group 其它的群組</li></ul><p>新增一個檔案的時候,<br>預設只有讀寫,沒有執行的權限 (100|010=110=&gt;6) </p><blockquote><p>指令 umask 的設定值以三個八進位的數字“nnn”代表。<br>第一個設定數字給使用者自己（owner user），<br>第二個則是設定給用使用者所屬的群體（group），<br>第三個給不屬於同群體的其它使用者（other）。<br>每一位數字的設定值都是三項不同權限的數值加總，<br>read 權限數值為 4；write 權限數值為 2；execute 權限數值為 1。<br>結合了前三者的權限數值，單一的數字可設定的範圍是 0 ~ 7；<br>整體的可設定範圍是 000 ~ 777。<br>— 鳥哥的 Linux 私房菜</p></blockquote><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a><code>ls</code></h3><h4 id="列出資料夾中的所有檔案"><a href="#列出資料夾中的所有檔案" class="headerlink" title="列出資料夾中的所有檔案"></a>列出資料夾中的所有檔案</h4><h4 id="ls-foldername"><a href="#ls-foldername" class="headerlink" title="ls foldername"></a><code>ls foldername</code></h4><p>列出指定的資料夾中所有的檔案</p><h4 id="ls-l"><a href="#ls-l" class="headerlink" title="ls -l"></a><code>ls -l</code></h4><p>列出資料夾中的所有檔案與其權限資訊</p><blockquote><p>ls 最常被使用到的功能還是那個 -l 的選項，為此，很多 distribution 在預設的情況中， 已經將 ll (L 的小寫) 設定成為 ls -l 的意思了！其實，那個功能是 <a href="http://linux.vbird.org/linux_basic/0320bash.php" target="_blank" rel="noopener">Bash shell</a> 的 <a href="http://linux.vbird.org/linux_basic/0320bash.php#alias" target="_blank" rel="noopener">alias</a> 功能呢<br>— 鳥哥的 Linux 私房菜</p></blockquote><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a><code>chmod</code></h3><h4 id="修改檔案權限"><a href="#修改檔案權限" class="headerlink" title="修改檔案權限"></a>修改檔案權限</h4><blockquote><p>sh-4.4$ ls -l<br>total 4<br>-rw-r–r– 1 33581 33581 978 Mar 12 17:30 README.txt<br>-rw-r–r– 1 33581 33581   0 Mar 12 17:32 test<br>sh-4.4$ chmod 777 test<br>sh-4.4$ ls -l<br>total 4<br>-rw-r–r– 1 33581 33581 978 Mar 12 17:30 README.txt<br>-rwxrwxrwx 1 33581 33581   0 Mar 12 17:32 test<br>sh-4.4$ chmod 444 test<br>sh-4.4$ ls -l<br>total 4<br>-rw-r–r– 1 33581 33581 978 Mar 12 17:30 README.txt<br>-r–r–r– 1 33581 33581   0 Mar 12 17:32 test</p></blockquote><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a><code>uname</code></h3><h4 id="顯示系統相關的資訊"><a href="#顯示系統相關的資訊" class="headerlink" title="顯示系統相關的資訊"></a>顯示系統相關的資訊</h4><blockquote><p>$ uname -a<br>Linux e955582759de 3.10.0-514.26.2.el7.x86_64 #1 SMP Tue Jul 4 15:04:05 UTC<br>2017 x86_64 x86_64 x86_64 GNU/Linux</p></blockquote><blockquote><p>選項與參數：<br>-a  ：所有系統相關的資訊，包括底下的資料都會被列出來；<br>-s  ：系統核心名稱<br>-r  ：核心的版本<br>-m  ：本系統的硬體名稱，例如 i686 或 x86_64 等；<br>-p  ：CPU 的類型，與 -m 類似，只是顯示的是 CPU 的類型！<br>-i  ：硬體的平台 (ix86)<br>— 鳥哥的 Linux 私房菜</p></blockquote><h3 id="file"><a href="#file" class="headerlink" title="file"></a><code>file</code></h3><h4 id="查詢檔案基本資料-類型"><a href="#查詢檔案基本資料-類型" class="headerlink" title="查詢檔案基本資料(類型)"></a>查詢檔案基本資料(類型)</h4><blockquote><p>file *</p></blockquote><blockquote><p>jazzy:  ASCII text<br>mark:   empty<br>marsen: directory</p></blockquote><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a><code>wc</code></h3><h4 id="顯示檔案資訊"><a href="#顯示檔案資訊" class="headerlink" title="顯示檔案資訊"></a>顯示檔案資訊</h4><p>行數 字數 字元數 檔名</p><blockquote><p>$ wc jazzy</p></blockquote><blockquote><p>3 10 39 jazzy</p></blockquote><h4 id="wc-l-filename"><a href="#wc-l-filename" class="headerlink" title="wc -l filename"></a><code>wc -l filename</code></h4><p>顯示檔案行數資訊</p><h4 id="wc-w-filename"><a href="#wc-w-filename" class="headerlink" title="wc -w filename"></a><code>wc -w filename</code></h4><p>顯示檔案字數資訊</p><h4 id="wc-c-filename"><a href="#wc-c-filename" class="headerlink" title="wc -c filename"></a><code>wc -c filename</code></h4><p>顯示檔案字元數資訊</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a><code>sort</code></h3><h4 id="印出排序過後的結果-遞增"><a href="#印出排序過後的結果-遞增" class="headerlink" title="印出排序過後的結果(遞增)"></a>印出排序過後的結果(遞增)</h4><blockquote><p>$ sort<br>owls<br>pigs<br>dogs<br>cats</p></blockquote><blockquote><p>cats<br>dogs<br>owls<br>pigs</p></blockquote><h4 id="sort-filename"><a href="#sort-filename" class="headerlink" title="sort filename"></a><code>sort filename</code></h4><p>印出檔案內排序過後的結果(遞增)</p><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a><code>cut</code></h3><h4 id="切割資料"><a href="#切割資料" class="headerlink" title="切割資料"></a>切割資料</h4><p>參數:<br>-d 分割字元<br>-f index (從1開始)</p><p>範例</p><blockquote><p>cat &gt; filenames<br>Name-Sport-Age<br>Roger-Tennis-30<br>Nadal-Tennis-25<br>Tiger-Golf-37<br>Michael-Baseball-49</p></blockquote><blockquote><p>$ cut -d”-“ -f 1,3 filenames<br>Name-Age<br>Roger-30<br>Nadal-25<br>Tiger-37<br>Michael-49</p></blockquote><h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a><code>dd</code></h3><h4 id="資料處理、拷貝、備份、轉碼-更多"><a href="#資料處理、拷貝、備份、轉碼-更多" class="headerlink" title="資料處理、拷貝、備份、轉碼;更多"></a>資料處理、拷貝、備份、轉碼;<a href="https://blog.gtwang.org/linux/dd-command-examples/" target="_blank" rel="noopener">更多</a></h4><blockquote><p>$ cat &gt; infile<br>this is the input file<br>$ cat infile<br>this is the input file</p></blockquote><blockquote><p>$ dd if=infile of=outfile conv=ucase<br>0+1 records in<br>0+1 records out<br>23 bytes copied, 6.6972e-05 s, 343 kB/s<br>$ cat outfile<br>THIS IS THE INPUT FILE </p></blockquote><h3 id="man"><a href="#man" class="headerlink" title="man"></a><code>man</code></h3><h4 id="查詢其它指令用法"><a href="#查詢其它指令用法" class="headerlink" title="查詢其它指令用法"></a>查詢其它指令用法</h4><blockquote><p>$ man ls<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LS(1)User Commands  LS(1)</span><br><span class="line">NAMEls - list directory contents</span><br><span class="line">SYNOPSISls [OPTION]... [FILE]...</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       List  information  about the FILEs (the current directory by default).  </span><br><span class="line">   Sort entries alphabetically if none of</span><br><span class="line">       -cftuvSUX nor --sort is specified.</span><br><span class="line"></span><br><span class="line">       Mandatory arguments to long options are mandatory for short options too.</span><br><span class="line">       -a, --all</span><br><span class="line">              do not ignore entries starting with .</span><br><span class="line"></span><br><span class="line">       -A, --almost-all</span><br><span class="line">              do not list implied . and ..</span><br><span class="line"></span><br><span class="line">       --author</span><br><span class="line">              with -l, print the author of each file</span><br><span class="line"></span><br><span class="line">       -b, --escape</span><br><span class="line">              print C-style escapes for nongraphic characters</span><br><span class="line"> Manual page ls(1) line 1 (press h for help or q to quit)</span><br></pre></td></tr></table></figure></p></blockquote><p>按<code>h</code>看更多訊息</p><blockquote><p>$ man ls<br>h</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                   SUMMARY OF LESS COMMANDS</span><br><span class="line"></span><br><span class="line">      Commands marked with * may be preceded by a number, N.</span><br><span class="line">      Notes in parentheses indicate the behavior if N is given.</span><br><span class="line"></span><br><span class="line">  h  H                 Display this help.</span><br><span class="line">  q  :q  Q  :Q  ZZ     Exit.</span><br><span class="line"> ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">                           MOVING</span><br><span class="line"></span><br><span class="line">  e  ^E  j  ^N  CR  *  Forward  one line   (or N lines).</span><br><span class="line">  y  ^Y  k  ^K  ^P  *  Backward one line   (or N lines).</span><br><span class="line">  f  ^F  ^V  SPACE  *  Forward  one window (or N lines).</span><br><span class="line">  b  ^B  ESC-v      *  Backward one window (or N lines).</span><br><span class="line">  z                 *  Forward  one window (and set window to N).</span><br><span class="line">  w                 *  Backward one window (and set window to N).</span><br><span class="line">  ESC-SPACE         *  Forward  one window, but don&apos;t stop at end-of-file.</span><br><span class="line">  d  ^D             *  Forward  one half-window (and set half-window to N).</span><br><span class="line">  u  ^U             *  Backward one half-window (and set half-window to N).</span><br><span class="line">  ESC-)  RightArrow *  Left  one half screen width (or N positions).</span><br><span class="line">  ESC-(  LeftArrow  *  Right one half screen width (or N positions).</span><br><span class="line">  F                    Forward forever; like &quot;tail -f&quot;.</span><br><span class="line">  r  ^R  ^L            Repaint screen.</span><br><span class="line">HELP -- Press RETURN for more, or q when done</span><br></pre></td></tr></table></figure><p>按<code>q</code>退出查詢畫面</p><h3 id="banner"><a href="#banner" class="headerlink" title="banner"></a><code>banner</code></h3><h4 id="輸出用-組成的大形文字"><a href="#輸出用-組成的大形文字" class="headerlink" title="輸出用#組成的大形文字"></a>輸出用#組成的大形文字</h4><p>實測未出現,上網查了一下banner好像有蠻多不同的類型可以安裝?</p><h3 id="compress"><a href="#compress" class="headerlink" title="compress"></a><code>compress</code></h3><h4 id="壓縮檔案"><a href="#壓縮檔案" class="headerlink" title="壓縮檔案"></a>壓縮檔案</h4><h3 id="zcat"><a href="#zcat" class="headerlink" title="zcat"></a><code>zcat</code></h3><h4 id="讀取壓縮檔案"><a href="#讀取壓縮檔案" class="headerlink" title="讀取壓縮檔案"></a>讀取壓縮檔案</h4><h3 id="uncompress"><a href="#uncompress" class="headerlink" title="uncompress"></a><code>uncompress</code></h3><h4 id="解壓縮檔案"><a href="#解壓縮檔案" class="headerlink" title="解壓縮檔案"></a>解壓縮檔案</h4><blockquote><p>compress 已經退流行了。為了支援 windows 常見的 zip，其實 Linux 也早就有 zip 指令了！ gzip 是由 <a href="http://www.gnu.org/" target="_blank" rel="noopener">GNU 計畫</a>所開發出來的壓縮指令，該指令已經取代了 compress 。<br>— 鳥哥的 Linux 私房菜</p></blockquote><h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>以上是一些基本的 Linux Command ,<br>下一篇,我們會建立.sh檔,將 Linux Command 依照指定的順序執行<br>並使用 <code>sh</code> 命令執行<br>用以完成一些更進階的工作. </p><p>(more..)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;參考&quot;&gt;&lt;a href=&quot;#參考&quot; class=&quot;headerlink&quot; title=&quot;參考&quot;&gt;&lt;/a&gt;參考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.tutorialspoint.com/unix_terminal_online.php
      
    
    </summary>
    
    
      <category term="Unix" scheme="http://blog.marsen.me/tags/Unix/"/>
    
      <category term="Linux" scheme="http://blog.marsen.me/tags/Linux/"/>
    
      <category term="Shell" scheme="http://blog.marsen.me/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>[學習筆記]AWS EC2 學習筆記 AWS CLI 與 Login</title>
    <link href="http://blog.marsen.me/2018/03/25/cloud_learn/aws_cli_login/"/>
    <id>http://blog.marsen.me/2018/03/25/cloud_learn/aws_cli_login/</id>
    <published>2018-03-25T15:01:24.000Z</published>
    <updated>2018-04-17T03:12:39.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安裝-AWS-CLI"><a href="#安裝-AWS-CLI" class="headerlink" title="安裝 AWS CLI"></a><a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/installing.html" target="_blank" rel="noopener">安裝 AWS CLI</a></h2><h2 id="配置-AWS-CLI"><a href="#配置-AWS-CLI" class="headerlink" title="配置 AWS CLI"></a><a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-chap-getting-started.html#cli-quick-configuration" target="_blank" rel="noopener">配置 AWS CLI</a></h2><h2 id="EC2-開機"><a href="#EC2-開機" class="headerlink" title="EC2 開機"></a>EC2 開機</h2><p><img src="https://i.imgur.com/dNGygaT.jpg" alt=""></p><ul><li>直接開機跳過網路設定(也還沒有辦法設)</li><li>第5步驟設定 TAG ,對找尋 ec2 的 instance 很有幫助</li></ul><h2 id="設定-Putty"><a href="#設定-Putty" class="headerlink" title="設定 Putty"></a>設定 <a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/putty.html?icmpid=docs_ec2_console" target="_blank" rel="noopener">Putty</a></h2><h2 id="連線機器"><a href="#連線機器" class="headerlink" title="連線機器"></a>連線機器</h2><p><img src="https://i.imgur.com/xIQsEac.jpg" alt=""></p><p>ex:  </p><blockquote><p>ssh -i /path/my-key-pair.pem <a href="mailto:ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com" target="_blank" rel="noopener">ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com</a></p></blockquote><h3 id="預設連線帳戶"><a href="#預設連線帳戶" class="headerlink" title="預設連線帳戶"></a>預設連線帳戶</h3><blockquote><p>For Amazon Linux, the user name is <code>ec2-user</code>.<br>For Centos, the user name is <code>centos</code>.<br>For Debian, the user name is <code>admin</code> or <code>root</code>.<br>For Fedora, the user name is <code>ec2-user</code>.<br>For RHEL, the user name is <code>ec2-user</code> or <code>root</code>.<br>For SUSE, the user name is <code>ec2-user</code> or <code>root</code>.<br>For Ubuntu, the user name is <code>ubuntu</code> or <code>root</code>.<br>Otherwise, if <code>ec2-user</code> and <code>root</code> don’t work, check with your AMI provider.</p></blockquote><p>windows 好像是 Administrator ? 求補充</p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h3 id="安裝-docker"><a href="#安裝-docker" class="headerlink" title="安裝 docker"></a>安裝 docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker</span><br></pre></td></tr></table></figure><h3 id="啟動-Docker-服務，並讓它隨系統啟動自動載入"><a href="#啟動-Docker-服務，並讓它隨系統啟動自動載入" class="headerlink" title="啟動 Docker 服務，並讓它隨系統啟動自動載入"></a>啟動 Docker 服務，並讓它隨系統啟動自動載入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker start</span><br><span class="line">$ sudo chkconfig docker on</span><br></pre></td></tr></table></figure><h3 id="雷包"><a href="#雷包" class="headerlink" title="雷包"></a>雷包</h3><ul><li>重啟機器的話 public dns 會改變.(意味連線的命令參數會變)</li><li><p>注意使用的AIM, 不同的 Linux OS 會有不同的套件執行命令</p><ul><li>ubuntu <code>apt-get</code></li><li>CentOS <code>yum</code><h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3></li></ul></li><li><p><a href="https://philipzheng.gitbooks.io/docker_practice" target="_blank" rel="noopener">Docker —— 從入門到實踐</a></p></li><li><a href="https://www.gitbook.com/book/joshhu/dockercommands/details" target="_blank" rel="noopener">全面易懂的Docker指令大全</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安裝-AWS-CLI&quot;&gt;&lt;a href=&quot;#安裝-AWS-CLI&quot; class=&quot;headerlink&quot; title=&quot;安裝 AWS CLI&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.aws.amazon.com/zh_cn/cli/latest/us
      
    
    </summary>
    
    
      <category term="AWS" scheme="http://blog.marsen.me/tags/AWS/"/>
    
      <category term="Root User" scheme="http://blog.marsen.me/tags/Root-User/"/>
    
      <category term="docker" scheme="http://blog.marsen.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>[讀書會]單元測試的藝術 - 導讀、序與第一章</title>
    <link href="http://blog.marsen.me/2018/03/22/2018/the_art_of_unit_testing_2nd_0/"/>
    <id>http://blog.marsen.me/2018/03/22/2018/the_art_of_unit_testing_2nd_0/</id>
    <published>2018-03-21T17:20:12.000Z</published>
    <updated>2018-04-17T03:12:39.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要知道的事"><a href="#要知道的事" class="headerlink" title="要知道的事"></a>要知道的事</h2><ol><li>這是<a href="http://www.books.com.tw/products/0010765689" target="_blank" rel="noopener">單元測試的藝術</a>的閱讀筆記</li><li>筆記的意思就是不一定會有心得</li><li>這篇主要是導讀</li></ol><h2 id="譯者序"><a href="#譯者序" class="headerlink" title="譯者序"></a>譯者序</h2><ul><li>TDD , Test First to Think First</li><li>什麼是好的單元測試？</li><li>單元測試三支柱:可信任 可讀性 可維護</li><li>綠色安全區域</li><li>實務上導入的指引</li></ul><h3 id="入門建議"><a href="#入門建議" class="headerlink" title="入門建議"></a>入門建議</h3><ul><li>了解如何隔離相依(Part II)</li><li>Stub 與 Mock 的差異,熟練隔離框架(NSubstitute)</li><li>如何撰寫優秀的單元測試(Part III)</li></ul><h3 id="進階建議"><a href="#進階建議" class="headerlink" title="進階建議"></a>進階建議</h3><ul><li>如何撰寫優秀的單元測試(Part III)</li><li>如何在組織中導入單元測試(Part IV)</li><li>針對遺留代碼的重構與測試,以及可測試性設計(Part IV)</li></ul><h3 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h3><ol><li>測試不穩定</li><li>過度指定</li><li>一次不只測一件事</li><li>測試程式重複過多</li><li>可讀性差</li></ol><h2 id="關於本書"><a href="#關於本書" class="headerlink" title="關於本書"></a>關於本書</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有寫測試, 也不保証專案成功,<br>一個失敗的單元測試案例,<br>作者歸納原因如下,  </p><ul><li>脆弱的測試(Prod改一點,測試就錯一大片)</li><li>不易維護</li><li>測試間相護依賴</li><li>可讀性差</li></ul><h3 id="作者推薦的框架"><a href="#作者推薦的框架" class="headerlink" title="作者推薦的框架"></a>作者推薦的框架</h3><ul><li><a href="http://nsubstitute.github.io" target="_blank" rel="noopener">NSubstitute</a></li><li><a href="https://github.com/FakeItEasy/FakeItEasy" target="_blank" rel="noopener">FakeItEasy</a></li></ul><h3 id="學習路線圖"><a href="#學習路線圖" class="headerlink" title="學習路線圖"></a>學習路線圖</h3><ul><li>Part I 基礎知識</li><li>Part II 測試框架</li><li>Part III 最佳實踐</li><li>Part IV 組識導入/遺留代碼/設計</li></ul><h2 id="目錄"><a href="#目錄" class="headerlink" title="目錄"></a>目錄</h2><ol><li>入門<ul><li>什麼是優秀的單元測試</li><li>單元測試與整合測試的分別</li><li>第一個單元測試</li></ul></li><li>核心技術<ul><li>Stub</li><li>IoC(DI)</li><li>值、狀態與互動</li><li>測試框架</li><li>事件</li><li>深入了解測試框架</li></ul></li><li>測試程式碼<ul><li>自動化</li><li>綠色安全區域</li><li>可信任/可維護/可讀性</li></ul></li><li>設計與流程<ul><li>組織導入</li><li>遺留代碼</li><li>設計與可測試性</li></ul></li></ol><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="定義單元測試"><a href="#定義單元測試" class="headerlink" title="定義單元測試"></a>定義單元測試</h3><h3 id="什麼是優秀的單元測試"><a href="#什麼是優秀的單元測試" class="headerlink" title="什麼是優秀的單元測試"></a>什麼是優秀的單元測試</h3><ol><li>自動化, 可重複執行</li><li>容易實現*</li><li>到第二天還有存在的意義(非臨時性的,ex:hotfix)</li><li>任何都可以一鍵執行</li><li>執行速度快</li><li>結果一致</li><li>可以完全控制(不與外部相依)</li><li>獨立於其他測試</li><li>失敗時,錯誤應該是明確的</li></ol><h3 id="整合測試"><a href="#整合測試" class="headerlink" title="整合測試"></a>整合測試</h3><ol><li>整合測試相依於真實物件</li><li>整合測試的結果不穩定</li><li>整合測試與單元測試應該被分開(見ch7.2.2)</li><li>整合測試執行時間長</li><li>依據現實狀況無法完全控制</li><li>缺點: 一次測試的東西太多</li></ol><h3 id="第一個單元測試"><a href="#第一個單元測試" class="headerlink" title="第一個單元測試"></a>第一個單元測試</h3><h3 id="理解測試趨動開發"><a href="#理解測試趨動開發" class="headerlink" title="理解測試趨動開發"></a>理解測試趨動開發</h3><ol><li>TDD 不保證產品會成功</li><li>步驟<ol><li>寫一個失敗的測試</li><li>寫一個符合測試預期的產品程式碼,以通過測試</li><li>重構</li></ol></li></ol><h3 id="TDD的核心技能"><a href="#TDD的核心技能" class="headerlink" title="TDD的核心技能"></a>TDD的核心技能</h3><ol><li>可維護、可讀、可靠(這本書的目的)</li><li>寫出可維護、可讀、可靠的測試不等於TDD,至於如何寫優秀的TDD,作者推薦閱讀<a href="https://www.tenlong.com.tw/products/9780321146533" target="_blank" rel="noopener">〈Test-Driven Development:by Example〉</a></li><li>就算執行TDD,也不保証能設計一個完善的系統,作者推薦閱讀<a href="http://tl.big5.zxhsd.com/kgsm/ts/big5/2010/07/30/1801246.shtml" target="_blank" rel="noopener">Growing Object-Oriented Software, Guided by Tests</a>與<a href="https://www.tenlong.com.tw/products/9789862017050" target="_blank" rel="noopener">無瑕的程式碼</a></li></ol><p>簡單說就是,</p><ul><li>寫好測試</li><li>測試先行(TDD)</li><li>設計</li></ul><p>作者認為這是三種技能, 同時學習三種技能門檻會相當的高, 最後導致放棄.</p><h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><ul><li>優秀的測試就是<ul><li>自動化</li><li>容易撰寫</li><li>執行快速</li><li>任何人都可以執行,並得到相同結果</li></ul></li></ul><h2 id="揪錯"><a href="#揪錯" class="headerlink" title="揪錯"></a>揪錯</h2><p><img src="https://i.imgur.com/olnQxQ2.jpg" alt=""></p><h2 id="本書資源"><a href="#本書資源" class="headerlink" title="本書資源"></a>本書資源</h2><ol><li><a href="https://github.com/royosherove/aout2" target="_blank" rel="noopener">Samples</a></li><li><a href="http://artofunittesting.com/" target="_blank" rel="noopener">The Art Of Unit Testing</a></li><li><a href="http://osherove.com/videos/" target="_blank" rel="noopener">Videos</a></li></ol><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;要知道的事&quot;&gt;&lt;a href=&quot;#要知道的事&quot; class=&quot;headerlink&quot; title=&quot;要知道的事&quot;&gt;&lt;/a&gt;要知道的事&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;這是&lt;a href=&quot;http://www.books.com.tw/products/00107656
      
    
    </summary>
    
    
      <category term="testing" scheme="http://blog.marsen.me/tags/testing/"/>
    
      <category term="TDD" scheme="http://blog.marsen.me/tags/TDD/"/>
    
      <category term="unit test" scheme="http://blog.marsen.me/tags/unit-test/"/>
    
      <category term="integration testing" scheme="http://blog.marsen.me/tags/integration-testing/"/>
    
  </entry>
  
  <entry>
    <title>[活動筆記]變異測試 - 一種改進測試和代碼的 「新」 方法</title>
    <link href="http://blog.marsen.me/2018/03/20/2018/mutation_testing/"/>
    <id>http://blog.marsen.me/2018/03/20/2018/mutation_testing/</id>
    <published>2018-03-19T17:44:00.000Z</published>
    <updated>2018-04-17T03:12:39.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="應該知道的事"><a href="#應該知道的事" class="headerlink" title="應該知道的事"></a>應該知道的事</h2><ul><li>範例使用Java</li><li>這場活動使用人肉找尋變異</li><li>實務上應使用工具</li><li>但是不能完全相信工具</li><li><a href="https://www.facebook.com/events/966762773499308/" target="_blank" rel="noopener">活動聯結</a></li><li>講師是 Odd-e 的姚若舟</li><li><a href="http://boolan.com/lecture/1000001089" target="_blank" rel="noopener">簡報preview版</a></li></ul><h2 id="什麼是變異"><a href="#什麼是變異" class="headerlink" title="什麼是變異 ?"></a>什麼是變異 ?</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想像一下產品(<code>Prodction</code>)就是你的身體,<br>我們可以透過健康檢查(<code>Unit Test</code>);<br>檢查你的身體有沒有異狀 ?  </p><p>但是檢查真的可靠嗎 ?<br>比如說一般的流感的快篩只有50~60%的準確率,<br>我們的測試也無法達到100%準確率(這裡不是指覆蓋率喔).<br>如何抓到測試抓不到的<strong>漏網之魚</strong>就是變異測試的目的.  </p><p>我們透過讓 Prodction 產生變異(Mutation)<br>來確認我們的 Unit Test 是否可靠.</p><blockquote><p>題外話,當大流行的時候會跳過快篩節省醫療資源,<br>因為可能有一半(50%)的患者都是流感,<br>而快篩準確率也只有50%,加上時間及醫材成本,<br>不如直接開克流感能有效抑止疫情</p></blockquote><h3 id="變異測試-Mutation-Testing"><a href="#變異測試-Mutation-Testing" class="headerlink" title="變異測試(Mutation Testing)"></a>變異測試(Mutation Testing)</h3><p>變異後導致測試失敗？<br><strong>yes , good</strong><br>應該要失敗,表示你的測試有覆蓋到這個變異</p><p><strong>no , test not covered</strong><br>這表示你的測試並未</p><h3 id="測試不一定能補捉變異"><a href="#測試不一定能補捉變異" class="headerlink" title="測試不一定能補捉變異"></a>測試不一定能補捉變異</h3><p>比如說 <code>邊際值</code> 或是 <code>隱含的互動</code>;<br>測試覆蓋率100%也不一定能補捉變異<br>要麼少了test case,<br>要麼多了無意義的代碼<br>看看以下例子<br>ex:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo(x,y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/ logic here</span></span><br><span class="line">    sideeffct();</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反思一下, 測試過了代碼就沒問題 ?<br>不能捉到變異的測試,<br>有發揮它的功能嗎 ?<br>一般來說如果透過 TDD 進行軟體開發,<br>我們的測試應該是會恰巧符合一項 Test Case<br>而如果是先寫代碼再寫測試,<br>將很難通過變異測試(容易產生多餘的代碼)</p><h3 id="找到變異的幾個方向"><a href="#找到變異的幾個方向" class="headerlink" title="找到變異的幾個方向"></a>找到變異的幾個方向</h3><ul><li>邊界條件(<code>&lt;</code> =&gt; <code>&lt;=</code>)</li><li>反向條件(<code>&lt;</code> =&gt; <code>&gt;</code>)</li><li>移除條件(永真/永偽)</li><li>數學</li><li>遞增/遞減</li><li>常量</li><li>返回值</li><li>移除代碼</li></ul><h3 id="先寫代碼再寫測試有問題是很正常的"><a href="#先寫代碼再寫測試有問題是很正常的" class="headerlink" title="先寫代碼再寫測試有問題是很正常的"></a>先寫代碼再寫測試有問題是很正常的</h3><h2 id="Kata-PokerHands-範例"><a href="#Kata-PokerHands-範例" class="headerlink" title="Kata-PokerHands 範例"></a>Kata-PokerHands 範例</h2><h3 id="原碼-使用java"><a href="#原碼-使用java" class="headerlink" title="原碼(使用java)"></a><a href="https://github.com/JosephYao/Kata-PokerHands" target="_blank" rel="noopener">原碼(使用java)</a></h3><h3 id="變異實例"><a href="#變異實例" class="headerlink" title="變異實例"></a>變異實例</h3><p>有問題 ,反向測試案例不足</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>List&lt;Integer&gt; <span class="title">getPairCardRanks</span><span class="params">(List&lt;Integer&gt; cardRanks)</span> </span>&#123;</span><br><span class="line">         List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; CARD_COUNT - <span class="number">1</span>; index++)</span><br><span class="line">         <span class="keyword">if</span> (isTwoNeighborCardRanksEquals(index, cardRanks))</span><br><span class="line">         result.add(cardRanks.get(index));</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有問題 , -1 但是預期中的行為<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span>   Integer   <span class="title">getThreeOfAKindCardRank</span><span class="params">(List&lt;Integer\&gt; cardRanks)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; CARD_COUNT - <span class="number">2</span>; index++)</span><br><span class="line">     <span class="keyword">if</span> (isThreeNeighborCardRanksEquals(index, cardRanks))</span><br><span class="line">     <span class="keyword">return</span>   cardRanks.get(index);</span><br><span class="line">     <span class="keyword">throw</span>   <span class="keyword">new</span>   IllegalStateException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol><li>沒有TDD 沒有單元測試,別跑變異測試</li><li>至少要有行級別的覆蓋率(line coverage)</li><li>分支覆蓋(Branch Coverage)好一點 仍不夠</li><li>在需求不變的情況下，再作變異測試</li><li>以變異測試的角度來說,覆蓋率100%是木有用的(testing coverage is useless)</li><li>發現變異怎麼辦？<ul><li>報告(記錄)</li><li>重現 </li><li>評估</li><li>修改 或 補測試</li></ul></li><li>依靠工具不要相信工具,上一步的評估<br>Ex: mock 物件會取代互動實際的行為,導致變異測試失敗</li></ol><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><ul><li><a href="http://pitest.org" target="_blank" rel="noopener">http://pitest.org</a></li><li><a href="https://en.wikipedia.org/wiki/Mutation_testing" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Mutation_testing</a></li><li>使用 Sonarqube with mulations test(應該不用錢)</li><li>tudou.com/home/yaoruozhou</li></ul><h2 id="參與者心得"><a href="#參與者心得" class="headerlink" title="參與者心得"></a>參與者心得</h2><ol><li><p><a href="https://medium.com/@loverjersey/變異測試-mutation-test-一種提高測試和代碼質量的-新-方法速記-35bde79a5c7a" target="_blank" rel="noopener">變異測試 (Mutation Test) — 一種提高測試和代碼質量的 ”新” 方法速記</a></p></li><li><p><a href="https://dotblogs.com.tw/im_sqz777/2018/03/15/004634" target="_blank" rel="noopener">Test - 變異(Mutation)測試之你的測試到底是寫爽的，還是有效的?</a></p></li></ol><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol><li>佩服當天就能寫出文章的人</li><li>變異測試是好上加好的測試</li><li>Odd-e 的講師真的很粉棒, 雖然不致到毀三觀 不過眼界大開</li></ol><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ol><li><a href="http://www.cnblogs.com/TongWee/p/4505289.html" target="_blank" rel="noopener">Mutation Testing(变异测试)</a></li></ol><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;應該知道的事&quot;&gt;&lt;a href=&quot;#應該知道的事&quot; class=&quot;headerlink&quot; title=&quot;應該知道的事&quot;&gt;&lt;/a&gt;應該知道的事&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;範例使用Java&lt;/li&gt;
&lt;li&gt;這場活動使用人肉找尋變異&lt;/li&gt;
&lt;li&gt;實務上應使用工具
      
    
    </summary>
    
    
      <category term="testing" scheme="http://blog.marsen.me/tags/testing/"/>
    
      <category term="TDD" scheme="http://blog.marsen.me/tags/TDD/"/>
    
      <category term="unit test" scheme="http://blog.marsen.me/tags/unit-test/"/>
    
      <category term="mutation teseting" scheme="http://blog.marsen.me/tags/mutation-teseting/"/>
    
  </entry>
  
  <entry>
    <title>[活動筆記]蝦皮購物新加坡研發團隊技術分享會</title>
    <link href="http://blog.marsen.me/2018/03/15/2018/shopee_tech_sharing/"/>
    <id>http://blog.marsen.me/2018/03/15/2018/shopee_tech_sharing/</id>
    <published>2018-03-15T09:00:12.000Z</published>
    <updated>2018-04-17T03:12:39.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="應該不用知道的事"><a href="#應該不用知道的事" class="headerlink" title="應該不用知道的事"></a>應該不用知道的事</h2><ol><li>雖然是「技術分享會」實際上在徵才</li><li>不過還是有半場的技術分享</li><li>91app 至少去了10 個人(含前員工) </li><li>這篇文章對你應該沒有幫助</li></ol><h2 id="有關蝦皮"><a href="#有關蝦皮" class="headerlink" title="有關蝦皮"></a>有關蝦皮</h2><ul><li>屬於<a href="http://www.seagroup.com/home" target="_blank" rel="noopener">Sea 集團</a>的一部份</li><li>東南亞多國服務(新加坡、泰國、馬來西亞、印度、台灣、越南…)</li><li>63e Request / Day</li><li>8G IO / Mins</li></ul><h2 id="選擇"><a href="#選擇" class="headerlink" title="選擇"></a>選擇</h2><ul><li>Native App / Web / Hybird / RN ?</li><li>Clound / Self machine ?</li><li>Php/ Nodejs / RoR / Django ?</li><li>Apache / Ngnix ?</li><li>C ++ / Java / GoLang</li><li>Memcahed / Redis ?</li><li>SPA / MPA ?</li><li>Mesos / Kubernate ?</li></ul><h2 id="Qiz-amp-Ans"><a href="#Qiz-amp-Ans" class="headerlink" title="Qiz &amp; Ans"></a>Qiz &amp; Ans</h2><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><blockquote><p>用戶下單的時候, 先收錢還是先扣庫存?<br>扣掉最後一件庫存後, 收錢失敗怎麼辦？<br>你已經把「賣完」訊息發給了賣家, 怎麼辦？</p></blockquote><h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><blockquote><p>計算金額用整數還是浮點數？(浮點數不準)</p></blockquote><h5 id="3"><a href="#3" class="headerlink" title="3"></a>3</h5><blockquote><p>Android 一共有幾種螢幕的 DPI ?<br>Android WebView 和 Chrome 的 Webkit 有何不同 ?</p></blockquote><h5 id="4"><a href="#4" class="headerlink" title="4"></a>4</h5><blockquote><p>Web Service 花最多時間在處理什麼 ?<br>如何壓搾最高的吞吐量 ?<br>IO, USE async</p></blockquote><h5 id="5"><a href="#5" class="headerlink" title="5"></a>5</h5><blockquote><p>什麼樣的情境適合增加伺服器數量來增進效能?<br>stateless<br>那有狀態怎麼辦 ? </p></blockquote><h5 id="6"><a href="#6" class="headerlink" title="6"></a>6</h5><blockquote><p>load balancer 效能到達瓶頸怎麼辦 ?<br>IP</p></blockquote><h5 id="7"><a href="#7" class="headerlink" title="7"></a>7</h5><blockquote><p>一天 25TB 的 Log 數量,怎麼不會查到天荒地老</p></blockquote><h5 id="8"><a href="#8" class="headerlink" title="8"></a>8</h5><blockquote><p>Cache &amp; 超賣問題<br>什麼時候要清 Cache ?</p></blockquote><h5 id="9"><a href="#9" class="headerlink" title="9"></a>9</h5><blockquote><p>Database Master 與 Slave 哪個壓力大 ?(Slave)<br>增加 index 的代價為何 ?(Space)<br>Table 多大要 shard ?<br>Database 多大要分庫 ?<br>分庫如何作 transaction ?</p></blockquote><h2 id="實踐"><a href="#實踐" class="headerlink" title="實踐"></a>實踐</h2><ol><li>Prototype 簡單 Production 困難 (邊際效應/熵)</li><li>可靠:言出必行,作不到也要早點說(知難行易)</li><li>Redis 的資料超過 64G 就無法用 <a href="http://redisdoc.com/server/bgsave.html" target="_blank" rel="noopener">bgsave</a> 有效存檔</li><li>在 Prodction 千萬別用 Redis 的 <a href="https://redis.io/commands/keys" target="_blank" rel="noopener">key</a> 指令</li><li>衡量的基準(benchmark)為何？</li><li>不要對邏輯下command(不要寫前因後果)<ul><li>Dont command How</li><li>Command Why</li></ul></li><li>道<ul><li>Collect your dots first</li><li>Connecting the dots</li></ul></li></ol><h2 id="持久發展的研發團隊"><a href="#持久發展的研發團隊" class="headerlink" title="持久發展的研發團隊"></a>持久發展的研發團隊</h2><ul><li>knowledge</li><li>保持開放</li><li>尊重事實</li><li>信任</li><li>可靠</li><li>找到根本原因(root cause)</li><li>分析 修復 記錄</li><li>Docs<ul><li>connection docs</li><li>collection docs</li></ul></li></ul><h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><ul><li>白箱測試</li><li>黑箱測試</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>Hypergraph</li><li>Tech Stack</li><li>Roles<ul><li>contries PM</li><li>fucntion PM</li></ul></li><li>Scurm 是跑給老闆看的(!!?)</li><li>馬來西亞不用小豬ICON(各地風俗民情不同)</li></ul><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://careers.shopee.com" target="_blank" rel="noopener">https://careers.shopee.com</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;應該不用知道的事&quot;&gt;&lt;a href=&quot;#應該不用知道的事&quot; class=&quot;headerlink&quot; title=&quot;應該不用知道的事&quot;&gt;&lt;/a&gt;應該不用知道的事&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;雖然是「技術分享會」實際上在徵才&lt;/li&gt;
&lt;li&gt;不過還是有半場的技術分享&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[翻譯]C# 的常見錯誤</title>
    <link href="http://blog.marsen.me/2018/02/12/2018/csharp_common_mistakes_1/"/>
    <id>http://blog.marsen.me/2018/02/12/2018/csharp_common_mistakes_1/</id>
    <published>2018-02-11T18:12:47.000Z</published>
    <updated>2018-04-17T03:12:39.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="出處"><a href="#出處" class="headerlink" title="出處"></a>出處</h2><p><a href="http://www.dotnetcurry.com/csharp/1417/csharp-common-mistakes" target="_blank" rel="noopener">http://www.dotnetcurry.com/csharp/1417/csharp-common-mistakes</a></p><h2 id="線上工具"><a href="#線上工具" class="headerlink" title="線上工具"></a>線上工具</h2><p><a href="https://dotnetfiddle.net" target="_blank" rel="noopener">https://dotnetfiddle.net</a></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>C#是個好棒棒的言語,但是它仍會有超乎你想像的行為,<br>而且就算你是有經驗的開發者,你也要看一看這篇文章.<br>這篇文章不講幹話,還會給你代碼喔  </p><p><img src="https://i.imgur.com/wXjvug6.jpg" alt="C# Quiz"></p><h3 id="Null-Value"><a href="#Null-Value" class="headerlink" title="Null Value"></a>Null Value</h3><p>Null 很危險啦, 你別在 Null 身上調用方法<br>(譯注:在公司的維運人員應該還蠻常見這個錯誤的 一ω一)  </p><blockquote><p>We are all aware that null values can be dangerous, if not handled properly.<br>Dereferencing a null-valued variable (i.e. calling a method on it or accessing one of its properties)<br>will result in a NullReferenceException, as demonstrated with the following sample code:  </p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> nullValue = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">bool</span> areNullValuesEqual = nullValue.Equals(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>就安全的角度,好像我們要不停的檢查 reference type 是不是 null ,<br>雖然這件事常常發生,好像也很難說成是非預期的行為了…<br>(譯注:又有種中槍的感覺)  </p><blockquote><p>To be on the safer side, we should always make sure that reference type values are not null before dereferencing them.<br>Failing to do so could result in an unhandled exception in a specific edge case.<br>Although such a mistake occasionally happens to everyone, we could hardly call it unexpected behavior.  </p></blockquote><p>看看這個代碼, null 值在 runtime 的時候不會有 type 的  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> nullString = (<span class="keyword">string</span>)<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">bool</span> isStringType = nullString <span class="keyword">is</span> <span class="keyword">string</span>;</span><br></pre></td></tr></table></figure><p><strong>No</strong>, null 值在 runtime 的時候不會有 type 的<br><strong>No</strong>, null 值在 runtime 的時候不會有 type 的<br><strong>No</strong>, null 值在 runtime 的時候不會有 type 的<br>很重要所以說三次,<br>當然你也別想呼叫 <code>GetType()</code> 方法  </p><blockquote><p>The correct answer is <strong>No</strong>.  </p><p>A null value has no type at runtime.  </p><p>In a way, this also affects reflection.<br>Of course, you can’t call GetType() on a null value because a NullReferenceException would get thrown:  </p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> nullValue = <span class="literal">null</span>;</span><br><span class="line">Type nullType = nullValue.GetType();</span><br></pre></td></tr></table></figure><p>純量呢？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> intValue = <span class="number">5</span>;</span><br><span class="line">Nullable&lt;<span class="keyword">int</span>&gt; nullableIntValue = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> areTypesEqual = intValue.GetType() == nullableIntValue.GetType();</span><br></pre></td></tr></table></figure><p>那我們可不可能用反射(reflection)區分 nullable 跟 non-nullable 的值？<br>答案是不可能, 看看後面的代碼  </p><blockquote><p>Is it possible to distinguish between a nullable and a non-nullable value type using reflection?  </p><p>The answer is <strong>No</strong>.  </p><p>The same type will be returned for both variables in the above code: System.Int32.<br>This does not mean that reflection has no representation for Nullable<t>, though.  </t></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type intType = <span class="keyword">typeof</span>(<span class="keyword">int</span>);</span><br><span class="line">Type nullableIntType = <span class="keyword">typeof</span>(Nullable&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line"><span class="keyword">bool</span> areTypesEqual = intType == nullableIntType;</span><br></pre></td></tr></table></figure><p>上面兩段程式在runtime拿到的type很不一樣喔,<br>一個是<code>System.Int32</code>一個是 <code>System.Nullable&#39;1\[System.Int32\]</code>  </p><h3 id="當-null-遇上多載方法-Handling-Null-values-in-Overloaded-methods"><a href="#當-null-遇上多載方法-Handling-Null-values-in-Overloaded-methods" class="headerlink" title="當 null 遇上多載方法 (Handling Null values in Overloaded methods)"></a>當 null 遇上多載方法 (Handling Null values in Overloaded methods)</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">string</span> <span class="title">OverloadedMethod</span>(<span class="params"><span class="keyword">object</span> arg</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"object parameter"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">string</span> <span class="title">OverloadedMethod</span>(<span class="params"><span class="keyword">string</span> arg</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"string parameter"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面有兩個<code>OverloadedMethod</code><br>猜猜看,傳入 null 時會呼叫哪一個方法？  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = OverloadedMethod(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>有人會猜編譯失敗嗎？<br>MAGIC ! 竟然可以編譯成功, 而回傳的值是 <strong>“string parameter”</strong> ,<br>一般來說,在編譯時期會作型別檢查,相同簽章的方法參數可以被轉型成另一個型別時,是可以編譯成功的喔.<br>而有明確型別的方法將被優先調用(譯注:求這段.Net Framework的原碼來看一下,知道的人請告訴我)  </p><p>如果要指定 null 參數呼叫的多載方法就要對 null 轉型唷,可以參考下面的方法.  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = OverloadedMethod((<span class="keyword">object</span>)<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="算術運算-Arithmetic-Operations"><a href="#算術運算-Arithmetic-Operations" class="headerlink" title="算術運算 (Arithmetic Operations)"></a>算術運算 (Arithmetic Operations)</h3><p>好像很少用位移運算吼？<br>回憶一下 左移移 右移移  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shifted = <span class="number">0</span>b1 &lt;&lt; <span class="number">1</span>; <span class="comment">// = 0b10</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shifted = <span class="number">0</span>b1 &gt;&gt; <span class="number">1</span>; <span class="comment">// = 0b0</span></span><br></pre></td></tr></table></figure><p>bits 跑到底並不會重頭開始喔,一直移位到爆掉就變 0 了.<br>(這裡會用32是因為 int 是32bit的數值,你可以試試放超過32的數值到for loop裡會發生什麼事)  </p><blockquote><p>The bits don’t wrap around when they reach the end.<br>That’s why the result of the second expression is 0.<br>The same would happen if we shifted the bit far enough to the left (32 bits because integer is a 32-bit number):  </p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shifted = <span class="number">0</span>b1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">shifted = shifted &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The result would again be 0.  </p></blockquote><p>那我們是不是可以一次移32bit,讓它一次變成0呢？<br>靠北啊 竟然不行捏, 你只會拿到 1,<br>這跟運算子(operator)基本運算有關,在作位元運算的時候,<br>會拿第一個運算數除以第二個運算數後取餘數,<br>這導致我們只會拿 32 % 32 的結果 , 也就是 1 啦<br>(譯注:這段其實我不是很確定,如果錯誤請糾正)  </p><blockquote><p>However, the bit shifting operators have a second operand.<br>Instead of shifting to the left by 1 bit 32 times, we can shift left by 32 bits and get the same result.  </p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shifted = <span class="number">0</span>b1 &lt;&lt; <span class="number">32</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Right? <strong>Wrong.</strong>  </p><p>The result of this expression will be 1. Why?  </p><p>Because that’s how the operator is defined. Before applying the operation,<br>the second operand will be normalized to the bit length of the first operand with the modulo operation,<br>i.e. by calculating the remainder of dividing the second operand by the bit length of the first operand.  </p><p>The first operand in the example we just saw was a 32-bit number, hence: 32 % 32 = 0.<br>Our number will be shifted left by 0 bits. That’s not the same as shifting it left by 1 bit 32 times.  </p></blockquote><p>好棒棒 你竟然可以看到這裡,<br>那我們繼續討論 &amp; (and) 跟 | (or) 運算子吧,<br>這兩個運算子跟一般的運算子有點不一樣  </p><ul><li>通常只要看運算子的第一個運算數就能得知結果  </li><li>在有掛 [Flag] atturibute的列舉它們好好用(看一下範例)  </li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> Colors</span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>b0,</span><br><span class="line">    Red = <span class="number">0</span>b1,</span><br><span class="line">    Green = <span class="number">0</span>b10,</span><br><span class="line">    Blue = <span class="number">0</span>b100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Colors color = Colors.Red | Colors.Green;</span><br><span class="line"><span class="keyword">bool</span> isRed = (color &amp; Colors.Red) == Colors.Red;</span><br></pre></td></tr></table></figure><p>上面這個刮號可不能省略喔, 因為(&amp;)運算符的優先順序低於(==)運算符,<br>不過這段程式沒有刮號的話連編譯都不會過,真是好加在<br>另外在 .NET framework 4.0 之後的版本提供更棒的方法去檢查flags  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isRed = color.HasFlag(Colors.Red);</span><br></pre></td></tr></table></figure><h3 id="Math-Round"><a href="#Math-Round" class="headerlink" title="Math.Round()"></a>Math.Round()</h3><p>猜一下這個值會是多少？  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rounded = Math.Round(<span class="number">1.5</span>);</span><br></pre></td></tr></table></figure><p>猜2的就答對了, 下一題<br>猜一下這個值會是多少？  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rounded = Math.Round(<span class="number">2.5</span>);</span><br></pre></td></tr></table></figure><p>還是2 ,<br>因為預設會取最接近的偶數</p><blockquote><p><strong>No.</strong> The result will be 2 again. By default,<br>the midpoint value will be rounded to the nearest even value.<br>You could provide the second argument to the method to request such behavior explicitly:  </p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rounded = Math.Round(<span class="number">2.5</span>, MidpointRounding.ToEven);</span><br></pre></td></tr></table></figure><p>這個行為可以透過<code>MidpointRounding</code>參數改變  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rounded = Math.Round(<span class="number">2.5</span>, MidpointRounding.AwayFromZero);</span><br></pre></td></tr></table></figure><p>另外要小心浮點數的精度問題,<br>以下的例子結果會是1,( 因為float的0.1實際上小於0.1 一ω一 )<br>這提醒我們在處理精確數值時,應轉換成整數處理.<br>(譯注:使用 <a href="https://dotnetfiddle.net" target="_blank" rel="noopener">dotnetfiddle</a> 時並不會有這個問題, 在windows 環境下測試的確會有問題)  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">value</span> = <span class="number">1.4</span>f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rounded = Math.Round(<span class="keyword">value</span> + <span class="number">0.1</span>f);</span><br></pre></td></tr></table></figure><h3 id="類別初始化"><a href="#類別初始化" class="headerlink" title="類別初始化"></a>類別初始化</h3><p>最佳實踐建我我們應該避免在建構子初始化類別,<br>特別是靜態建構子.<br>在初始化一個類別的順序如下</p><ol><li>靜態欄位</li><li>靜態建構子</li><li>實體欄位</li><li>實體建構子</li></ol><p>看看這個例子<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Config</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> ThrowException &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FailingClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">FailingClass</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Config.ThrowException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>當我們嚐試實例化FailingClass時,你會得到Exception;<br>值得注意的事,你拿到的會是<code>TypeInitializationException</code><br>而並不是<code>InvalidOperationException</code>,  </p><p>那麼我們是不是可以試著透過try catch補捉錯誤,<br>並修改靜態屬性,重新實體化class呢？<br><strong>答案是不行</strong></p><p>一個靜態建構值,如果它拋出一個異常,<br>那麼無論何時你想創建一個實例或以任何其他方式訪問這個類,<br>這個異常都會被重新拋出.  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> failedInstance = <span class="keyword">new</span> FailingClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeInitializationException) &#123; &#125;</span><br><span class="line">Config.ThrowException = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> FailingClass();</span><br></pre></td></tr></table></figure><p>這個類別在程序重啟前是不能再被使用了(會拋出錯誤),<br>這在 C# 是個非常糟糕的實踐,<br>千萬別這樣設計你的類別.  </p><blockquote><p>The static constructor for a class is only called once.<br>If it throws an exception, then this exception will be rethrown<br>whenever you want to create an instance or access the class in any other way.  </p><p>The class becomes effectively unusable until the process (or the application domain) is restarted.<br>Yes, having even a minuscule chance that the<br>static constructor will throw an exception, is a very bad idea.  </p></blockquote><h4 id="繼承與類別初始化"><a href="#繼承與類別初始化" class="headerlink" title="繼承與類別初始化"></a>繼承與類別初始化</h4><p>繼承的類別初始化執行順序更加複雜,看看下面的例子</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseClass</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        VirtualMethod(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">VirtualMethod</span>(<span class="params"><span class="keyword">int</span> dividend</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dividend / <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> divisor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DerivedClass</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        divisor = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">int</span> <span class="title">VirtualMethod</span>(<span class="params"><span class="keyword">int</span> dividend</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.VirtualMethod(dividend / divisor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>當我們初始化 DerivedClass</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> DerivedClass();</span><br></pre></td></tr></table></figure><p>你會得到一個除0的錯誤 <code>DivideByZeroException</code><br>這與執行順序有關</p><ol><li>呼叫 BaseClass 建構子</li><li>執行 DerivedClass VirtualMethod (overrid BaseClass)</li><li>divisor 未賦值拋出 <code>DivideByZeroException</code></li></ol><h2 id="多形-Polymorphism"><a href="#多形-Polymorphism" class="headerlink" title="多形 Polymorphism"></a>多形 Polymorphism</h2><p>這個例子只是要說明多形的概念與應用,<br>你可以透過轉形呼叫基底類別的方法.  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> DerivedClass();</span><br><span class="line"><span class="keyword">var</span> result = instance.Method(); <span class="comment">// -&gt; Method in DerivedClass</span></span><br><span class="line">result = ((BaseClass)instance).Method(); <span class="comment">// -&gt; Method in BaseClass</span></span><br><span class="line"><span class="comment">// The correct answer is: by using the new modifier.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">string</span> <span class="title">Method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Method in BaseClass "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> new <span class="keyword">string</span> <span class="title">Method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Method in DerivedClass"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>It’s typically used to hide the interface methods from the consumers of the class implementing it,<br>unless they cast the instance to that interface.<br>But it works just as well if we want to have two different implementations of a method inside a single class.<br>It’s difficult to think of a good reason for doing it, though.</p></blockquote><p>另外一個例子是明確實作介面方法,<br>如果你的類別已經有同名的方法的話.<br>雖然沒有什麼好理由建議你這樣作.<br>(譯注:實務上我有在遇到歷史共業這樣作過…)  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> DerivedClass();</span><br><span class="line"><span class="keyword">var</span> result = instance.Method(); <span class="comment">// -&gt; Method in DerivedClass</span></span><br><span class="line">result = ((IInterface)instance).Method(); <span class="comment">// -&gt; Method belonging to IInterface</span></span><br><span class="line">It’s explicit interface implementation.</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">string</span> <span class="title">Method</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">IInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Method in DerivedClass"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">string</span> IInterface.Method()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Method belonging to IInterface"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">It’s</span><br></pre></td></tr></table></figure><h2 id="迭代器-Iterators"><a href="#迭代器-Iterators" class="headerlink" title="迭代器 Iterators"></a>迭代器 Iterators</h2><p>小心 Iterators 的陷阱<br>看看以下<a href="https://dotnetfiddle.net/BxfF0d" target="_blank" rel="noopener">代碼</a>:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">GetEnumerable</span>(<span class="params">StringBuilder log</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> context = <span class="keyword">new</span> Context(log))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Context</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> StringBuilder log;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span>(<span class="params">StringBuilder log</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.log = log;</span><br><span class="line">        <span class="keyword">this</span>.log.AppendLine(<span class="string">"Context created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.log.AppendLine(<span class="string">"Context disposed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假設我們 foreach 呼叫 GetEnumerable 方法,<br>你預期 Context 類別會有什麼樣的行為？<br>我們會印出以下的output嗎？</p><blockquote><p>Context created<br>1<br>2<br>3<br>4<br>5<br>Context disposed</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> log = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> number <span class="keyword">in</span> <span class="title">GetEnumerable</span>(<span class="params">log</span>))</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    log.AppendLine(<span class="string">$"<span class="subst">&#123;number&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不是的,<br>實際上印出的是</p><blockquote><p>Context created<br>Context disposed<br>1<br>2<br>3<br>4<br>5</p></blockquote><p>這點很重要,<br>因為實務上你很有可能 using dbconnetion 之類的物件,<br>那麼你在取得真正的資料之前,<br>你的連線就已經中斷了 </p><blockquote><p>This means that in our real world database example, the code would fail –<br>the connection would be closed before the values could be read from the database.</p></blockquote><p>看看以下的<a href="https://dotnetfiddle.net/IgJaak" target="_blank" rel="noopener">修正</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">GetEnumerable</span>(<span class="params">StringBuilder log</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> context = <span class="keyword">new</span> Context(log))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> i <span class="keyword">in</span> Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>譯注:看到這裡對 <code>yield return</code> 的使用情境才比較有感啊…</p><p>如果你不太熟<code>yield return</code>,其實它只是個語法糖,允許增量執行,<br>參考以下範例,或許能更容易理解</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">GetCustomEnumerable</span>(<span class="params">StringBuilder log</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    log.AppendLine(<span class="string">"before 1"</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    log.AppendLine(<span class="string">"before 2"</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    log.AppendLine(<span class="string">"before 3"</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    log.AppendLine(<span class="string">"before 4"</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    log.AppendLine(<span class="string">"before 5"</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    log.AppendLine(<span class="string">"before end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> log = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">log.AppendLine(<span class="string">"before enumeration"</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> number <span class="keyword">in</span> <span class="title">GetCustomEnumerable</span>(<span class="params">log</span>))</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    log.AppendLine(<span class="string">$"<span class="subst">&#123;number&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br><span class="line">log.AppendLine(<span class="string">"after enumeration"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>before enumeration<br>before 1<br>1<br>before 2<br>2<br>before 3<br>3<br>before 4<br>4<br>before 5<br>5<br>before end<br>after enumeration</p></blockquote><p>值得注意的事, 如果你在loop當中重複執行以上的代碼,<br>那麼 Iterators 也會重複執行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> log = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">var</span> enumerable = GetCustomEnumerable(log);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    log.AppendLine(<span class="string">$"enumeration #<span class="subst">&#123;i&#125;</span>"</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> enumerable)</span><br><span class="line">    &#123;</span><br><span class="line">        log.AppendLine(<span class="string">$"<span class="subst">&#123;number&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>輸出如下,可以明顯看到 <code>GetCustomEnumerable</code> 方法,<br>實際上被隱含的執行了兩次,<br>這在 Code Review 的階段也是難以被察覺的.</p><blockquote><p>enumeration #1<br>before 1<br>1<br>before 2<br>2<br>before 3<br>3<br>before 4<br>4<br>before 5<br>5<br>before end<br>enumeration #2<br>before 1<br>1<br>before 2<br>2<br>before 3<br>3<br>before 4<br>4<br>before 5<br>5<br>before end</p></blockquote><p>比較好的作法是將 <code>IEnumerable</code> ToList(),<br>如果你真的需要對 <code>IEnumerable</code> 的結果作 loop 的操作</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> log = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">var</span> enumerable = GetCustomEnumerable(log).ToList();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    log.AppendLine(<span class="string">$"enumeration #<span class="subst">&#123;i&#125;</span>"</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> enumerable)</span><br><span class="line">    &#123;</span><br><span class="line">        log.AppendLine(<span class="string">$"<span class="subst">&#123;number&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>輸出結果</p><blockquote><p>before 1<br>before 2<br>before 3<br>before 4<br>before 5<br>before end<br>enumeration #1<br>1<br>2<br>3<br>4<br>5<br>enumeration #2<br>1<br>2<br>3<br>4<br>5</p></blockquote><h2 id="譯者小結"><a href="#譯者小結" class="headerlink" title="譯者小結"></a>譯者小結</h2><p>如果真的能夠預期所有的行為的開發人員,<br>真的是好棒棒,<br>對我來說 static class constructor 的行為是超乎預期的,<br>然後對 <code>yield return</code> 的使用場景更有感覺了.<br>本來預計農曆年就可以完成的翻譯,<br>竟然也拖了這麼久,看來我英文還是不行啊. </p><p>希望對大家有幫助,也請多多看原文 :)</p><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;出處&quot;&gt;&lt;a href=&quot;#出處&quot; class=&quot;headerlink&quot; title=&quot;出處&quot;&gt;&lt;/a&gt;出處&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.dotnetcurry.com/csharp/1417/csharp-common-mistakes
      
    
    </summary>
    
    
      <category term="C#" scheme="http://blog.marsen.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>[學習筆記]AWS 註冊到建立安全性帳戶</title>
    <link href="http://blog.marsen.me/2018/01/26/cloud_learn/aws_startup_with_iam/"/>
    <id>http://blog.marsen.me/2018/01/26/cloud_learn/aws_startup_with_iam/</id>
    <published>2018-01-26T06:24:16.000Z</published>
    <updated>2018-04-17T03:12:39.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="該知道的事"><a href="#該知道的事" class="headerlink" title="該知道的事"></a>該知道的事</h2><ol><li>僅作為學習 AWS 的過程記錄用</li><li>可能對你有幫助</li><li>可能對你沒幫助</li><li>有沒有幫助都歡迎你提出問題與討論 </li></ol><h2 id="創建帳號"><a href="#創建帳號" class="headerlink" title="創建帳號"></a>創建帳號</h2><p>這段蠻簡單的,不贅敘<br>特別一提的事<code>可以使用有VISA的金融卡作金額控管</code><br>比起信用卡動輒數萬到數十萬的額度,<br>金融卡可以更彈性,而且精準的控制預算.</p><p>另外說一下,現在AWS有一年的免費額度(已經有好一陣子了),<br><del>在註冊流程跳過付款方式的設定,</del><br><del>實際上也是可以操作的AWS的(目前只有設定IAM).</del><br>(2018/01/31更新)<br>確定<code>可以使用有VISA的金融卡</code>開戶,<br>另外當要實際使用 AWS 的服務時 EX: EC2, Lambda etc…<br>需要綁定信用卡(VISA金融卡也可以)才能繼續使用.</p><p>綁定的過程會需要輸入電話,<br>AWS 會撥一通電話給你,<br>螢幕上會出現4個數字,<br>照畫面輸入即可完成信用卡(VISA金融卡)的驗証.</p><h2 id="權限控管"><a href="#權限控管" class="headerlink" title="權限控管"></a>權限控管</h2><h3 id="Root-User"><a href="#Root-User" class="headerlink" title="Root User"></a>Root User</h3><p><img src="https://i.imgur.com/kRBApSO.jpg" alt=""><br>完成註冊後,一開始只能使用email登入,這個帳號可以存取AWS所有服務.<br>AWS<strong>不建議使用Root User作為日常的管理帳戶, Root User 應該只被用來建立第一個IAM</strong></p><h4 id="重點項目"><a href="#重點項目" class="headerlink" title="重點項目"></a>重點項目</h4><ol><li><p>Root User 啟用 <a href="https://aws.amazon.com/iam/details/mfa/" target="_blank" rel="noopener">MFA</a><br><img src="https://i.imgur.com/X3T5poV.jpg" alt=""><br>首先要下載驗証程式(Google Authenticator),<br>然後下一步到以下畫面時, 用Authenticator掃瞄QR Code,<br><strong>連續輸入兩次授權碼(輸入完第一組後,等待新的授權碼出現再輸入)</strong><br><img src="https://i.imgur.com/viNBe2p.jpg" alt=""><br>可以在 <a href="https://console.aws.amazon.com/iam/home" target="_blank" rel="noopener">IAM Console</a> 檢查成功了沒<br><img src="https://i.imgur.com/JcC9NVz.jpg" alt=""></p></li><li><p>建立 IAM User 與指定 Group 權限<br>AWS IAM 的權限觀念是透過 User 與 Group 來組合的,<br>權限是授與 Group , 而 User 隸屬於 Group 便擁有其權限,<br>同時 AWS 提供多組(347組)預設的 Policies, 讓人選擇<br>當然也可以建立自已的 Policy.<br>*<em>不確定有沒有反向的 Policy ,</em><br><em>如果有當不同的 Group Policy 有衝突時該如何處理.</em></p></li></ol><p><img src="https://i.imgur.com/Ry9M2sj.jpg" alt=""><br>建立使用者時, 使用AutoGenerated Password時<br>要記得取得 password<br>在最後一步會按下show就會顯示<br><img src="https://i.imgur.com/8DOmpsg.jpg" alt=""></p><ol start="3"><li>設定 AWS Account ID 與 Alias<br><img src="https://i.imgur.com/ETV1LMR.jpg" alt=""></li></ol><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><ol><li>如何禁用 Root user 登入 ? 可以停用而不刪除一個 user account 嗎？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root account 無法停用</span><br><span class="line">IAM User 可以透過 disable passwd 方式停用</span><br><span class="line">root account 基本的 practice</span><br><span class="line">1. 啟用 MFA</span><br><span class="line">2. 移除 Access Creditenail</span><br><span class="line">概念就跟 Winodws Administrator or Linux root 一樣</span><br><span class="line">需要時再用</span><br></pre></td></tr></table></figure></li></ol><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_root-user.html" target="_blank" rel="noopener">Root User Account</a></li><li><a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#create-iam-users" target="_blank" rel="noopener">建立第一個IAM USER</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;該知道的事&quot;&gt;&lt;a href=&quot;#該知道的事&quot; class=&quot;headerlink&quot; title=&quot;該知道的事&quot;&gt;&lt;/a&gt;該知道的事&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;僅作為學習 AWS 的過程記錄用&lt;/li&gt;
&lt;li&gt;可能對你有幫助&lt;/li&gt;
&lt;li&gt;可能對你沒幫助&lt;/
      
    
    </summary>
    
    
      <category term="AWS" scheme="http://blog.marsen.me/tags/AWS/"/>
    
      <category term="IAM" scheme="http://blog.marsen.me/tags/IAM/"/>
    
      <category term="Root User" scheme="http://blog.marsen.me/tags/Root-User/"/>
    
  </entry>
  
  <entry>
    <title>[好文分享]應用部署的六種策略</title>
    <link href="http://blog.marsen.me/2018/01/07/2018/six_strategies_for_application_deployment/"/>
    <id>http://blog.marsen.me/2018/01/07/2018/six_strategies_for_application_deployment/</id>
    <published>2018-01-07T10:47:51.000Z</published>
    <updated>2018-04-17T03:12:39.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用出處"><a href="#引用出處" class="headerlink" title="引用出處"></a>引用出處</h2><ul><li><a href="https://thenewstack.io/deployment-strategies/" target="_blank" rel="noopener">原文出處</a></li><li><a href="https://itw01.com/22ULE7O.html" target="_blank" rel="noopener">中譯出處</a></li></ul><h2 id="正文開始"><a href="#正文開始" class="headerlink" title="正文開始"></a>正文開始</h2><p>目前有各種各樣的技術來將新應用部署到生產環境，<br>所以權衡對系統和終端使用者的影響降至最少，選擇正確的方式是非常重要的。<br>本文將著重討論如下部署策略：   </p><ul><li>重建部署：版本A下線後版本B上線 </li><li>滾動部署（滾動更新或者增量釋出）：版本B緩慢更新並替代版本A </li><li>藍綠部署：版本B並行與版本A釋出，然後流量切換到版本B </li><li>金絲雀部署：版本B向一部分使用者釋出，然後完全放開 </li><li>A/B部署布：版本B只向特定條件的使用者釋出 </li><li>影子部署：版本B接受真實的流量請求，但是不產生響應 </li></ul><p>我們來看一下每個策略最適合哪種使用者使用場景。<br>爲了簡化，我們使用 <a href="https://kubernetes.io" target="_blank" rel="noopener">Kubernetes</a> ，並用 <a href="https://github.com/ContainerSolutions/k8s-deployment-strategies" target="_blank" rel="noopener">Minikube</a> 進行例子演示。<br>每個策略的配置例子和詳細步驟都可以在這個 <a href="https://github.com/ContainerSolutions/k8s-deployment-strategies" target="_blank" rel="noopener">git倉庫</a> 上找到。   </p><h3 id="重建部署"><a href="#重建部署" class="headerlink" title="重建部署"></a>重建部署</h3><p>重建策略是一個冗餘的方式，它包含下線版本A，然後部署版本B。<br>這個方式意味著服務的宕機時間依賴於應用下線和啟動耗時。<br><img src="/images/2018/six_strategies_for_application_deployment/recreate.gif" alt=""></p><p>優點： </p><ul><li>便於設定 </li><li>應用狀態完整更新 </li></ul><p>缺點： </p><ul><li>對使用者影響很大，預期的宕機時間取決於下線時間和應用啟動耗時 </li></ul><h3 id="滾動部署"><a href="#滾動部署" class="headerlink" title="滾動部署"></a>滾動部署</h3><p>滾動部署策略是指通過逐個替換應用的所有例項，<br>來緩慢釋出應用的一個新版本。<br>通常過程如下：<br>在負載排程後有個版本A的應用例項池，<br>一個版本B的例項部署成功，可以響應請求時，<br>該例項被加入到池中。<br>然後版本A的一個例項從池中刪除並下線。<br>考慮到滾動部署依賴於系統，<br>可以調整如下引數來增加部署時間： </p><ul><li>並行數，最大批量執行數：同時釋出例項的數目 </li><li>最大峰值：考慮到當前例項數，例項可以加入的數目 </li><li>最大不可用數：在滾動更新過程中不可用的例項數<br><img src="/images/2018/six_strategies_for_application_deployment/ramped.gif" alt=""><br>優點： </li><li>便於設定 </li><li>版本在例項間緩慢釋出 </li><li>對於能夠處理資料重平衡的有狀態應用非常方便<br>缺點： </li><li>釋出/回滾耗時 </li><li>支援多個API很困難 </li><li>無法控制流量 </li></ul><h2 id="藍綠部署"><a href="#藍綠部署" class="headerlink" title="藍綠部署"></a>藍綠部署</h2><p>藍綠部署策略與滾動部署不同，<br>版本B（綠）同等數量的被並排部署在版本A（藍）旁邊。<br>當新版本滿足上線條件的測試後，<br>流量在負載均衡層從版本A切換到版本B。<br><img src="/images/2018/six_strategies_for_application_deployment/blue-green.gif" alt=""><br>優點： </p><ul><li>實時釋出、回滾 </li><li>避免版本衝突問題，整個應用狀態統一一次切換<br>缺點： </li><li>比較昂貴因為需要雙倍的資源 </li><li>在釋放版本到生產環境之前，整個平臺的主流程測試必須執行 </li><li>處理有狀態的應用很棘手 </li></ul><h3 id="金絲雀部署"><a href="#金絲雀部署" class="headerlink" title="金絲雀部署"></a>金絲雀部署</h3><p>金絲雀部署是指逐漸將生產環境流量從版本A切換到版本B。<br>通常流量是按比例分配的。<br>例如90%的請求流向版本A，10%的流向版本B。<br>這個技術大多數用於缺少足夠測試，或者缺少可靠測試，<br>或者對新版本的穩定性缺乏信心的情況下。<br><img src="/images/2018/six_strategies_for_application_deployment/canary.gif" alt=""><br>優點： </p><ul><li>版本面向一部分使用者釋出 </li><li>方便錯誤評估和效能監控 </li><li>快速回滾<br>缺點： </li><li>釋出緩慢 </li></ul><h3 id="A-B測試"><a href="#A-B測試" class="headerlink" title="A/B測試"></a>A/B測試</h3><p>A/B測試是指在特定條件下將一部分使用者路由到新功能上。<br>它通常用於根據統計來制定商業決策，而不是部署策略。<br>然而，他們是相關的，可以在金絲雀部署方式上新增額外功能來實現，所以我們這裏簡要介紹一下。<br>這個技術廣泛用於測試特定功能的切換，併發布使用佔大部分的版本。<br>下面是可以用於在版本間分散流量的條件：  </p><ul><li>瀏覽器cookie </li><li>查詢引數 </li><li>地理位置 </li><li>技術支援：瀏覽器版本、螢幕尺寸、作業系統等 </li><li>語言<br><img src="/images/2018/six_strategies_for_application_deployment/a-b.gif" alt=""><br>優點： </li><li>多個版本並行執行 </li><li>完全控制流量分佈<br>缺點： </li><li>需要智慧負載均衡 </li><li>對於給定的會話，很難定位問題，分散式跟蹤是必須的 </li></ul><h3 id="影子部署"><a href="#影子部署" class="headerlink" title="影子部署"></a>影子部署</h3><p>影子部署是指在版本A旁邊釋出版本B，<br>將版本A進來的請求同時分發到版本B，<br>同時對生產環境流量無影響。<br>這是測試新特徵在產品負載上表現的很好用的方式。<br>當滿足上線要求後，則觸發釋出新應用。<br>這個技術配置非常複雜，而且需要特殊條件，尤其是分出請求。<br>例如一個購物車平臺，如果你想影子測試支付服務，<br>你可能最終會是使用者為他們的訂單支付兩次。<br>這種情況下，可以通過建立一個模擬的服務來重複響應使用者的請求。<br><img src="/images/2018/six_strategies_for_application_deployment/shadow.gif" alt=""><br>優點： </p><ul><li>可以使用生產環境流量進行效能測試 </li><li>對使用者無影響 </li><li>直到應用的穩定性和效能滿足要求後才釋出<br>缺點： </li><li>雙倍資源，成本昂貴 </li><li>不是真實使用者測試，可能出現誤導 </li><li>配置複雜 </li><li>某種情況下需要模擬服務 </li></ul><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>部署應用有很多種方法，實際採用哪種方式取決於需求和預算。<br>當釋出到開發或者模擬環境時，重建或者滾動部署是一個好選擇。<br>當釋出到生產環境時，滾動部署或者藍綠部署通常是一個好選擇，<br>但是新平臺的主流程測試是必須的。<br>藍綠部署和影子部署對預算有更高的要求，因為需要雙倍資源。<br>如果應用缺乏測試或者對軟體的功能和穩定性影響缺乏信心，<br>那麼可以使用金絲雀部署或者AB測試或者影子釋出。<br>如果業務需要根據地理位置、語言、作業系統或者瀏覽器特徵等這樣引數來給一些特定的使用者測試，那麼可以採用AB測試技術。<br>最後但並不是最不重要的，影子釋出很複雜，且需要額外工作來模擬響應分支流量請求，<br>當可變操作（郵件、銀行等）呼叫外部依賴時這是必須的，<br>這個技術在升級新資料庫是非常有用，使用影子流量來監控負載下的系統性能。<br>下表可以幫助你選擇正確的策略：<br><img src="/images/2018/six_strategies_for_application_deployment/deployment_strategies.png" alt=""><br>取決於雲服務提供商和平臺，如下文件是理解部署的很好開始：   </p><ul><li>Amazon Web Services </li><li>Docker Swarm </li><li>Google Cloud </li><li>Kubernetes<br>我希望這是有用的，如果有任何問題或者反饋，可以在下面評論<br>(正文結束)</li></ul><h2 id="補充表格翻譯"><a href="#補充表格翻譯" class="headerlink" title="補充表格翻譯"></a>補充表格翻譯</h2><table><thead><tr><th>策略</th><th>服務不斷線</th><th>真實環境測試</th><th>目標客戶分群</th><th>預算成本</th><th>退版時間</th><th>使用者影響</th><th>複雜度</th></tr></thead><tbody><tr><td>重建部署</td><td>✖</td><td>✖</td><td>✖</td><td>★☆☆</td><td>★★★</td><td>★★★</td><td>☆☆☆</td></tr><tr><td>滾動部署</td><td>✔</td><td>✖</td><td>✖</td><td>★☆☆</td><td>★★★</td><td>★☆☆</td><td>★☆☆</td></tr><tr><td>藍綠部署</td><td>✔</td><td>✖</td><td>✖</td><td>★★★</td><td>☆☆☆</td><td>★★☆</td><td>★★☆</td></tr><tr><td>金絲雀部署</td><td>✔</td><td>✔</td><td>✖</td><td>★☆☆</td><td>★☆☆</td><td>★☆☆</td><td>★★☆</td></tr><tr><td>A/B部署</td><td>✔</td><td>✔</td><td>✔</td><td>★☆☆</td><td>★☆☆</td><td>★☆☆</td><td>★★★</td></tr><tr><td>影子部署</td><td>✔</td><td>✔</td><td>✖</td><td>★★★</td><td>☆☆☆</td><td>☆☆☆</td><td>★★★</td></tr></tbody></table><p>非常實用的文章,可惜中譯的圖片並非gif,原文的超聯結也掉失,<br>特別重新修正以上問題,留作記錄</p><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引用出處&quot;&gt;&lt;a href=&quot;#引用出處&quot; class=&quot;headerlink&quot; title=&quot;引用出處&quot;&gt;&lt;/a&gt;引用出處&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://thenewstack.io/deployment-strategies/&quot; 
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="http://blog.marsen.me/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>代碼審查與交付的戰爭ー標準、風格與原則</title>
    <link href="http://blog.marsen.me/2018/01/04/2018/coding_standard_and_coding_style_and_principle/"/>
    <id>http://blog.marsen.me/2018/01/04/2018/coding_standard_and_coding_style_and_principle/</id>
    <published>2018-01-03T16:51:27.000Z</published>
    <updated>2018-04-17T03:12:39.583Z</updated>
    
    <content type="html"><![CDATA[<h6 id="Coding-Standard-Code-Review-Pull-Request-amp-Delivery"><a href="#Coding-Standard-Code-Review-Pull-Request-amp-Delivery" class="headerlink" title="Coding Standard / Code Review / Pull Request &amp; Delivery"></a>Coding Standard / Code Review / Pull Request &amp; Delivery</h6><p><img src="https://i.imgur.com/tssraf0.jpg" alt=""></p><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><ol><li>團隊的部署流程是 Github Flow 與 Git Flow 混用 , 給它起個名字叫 GG Flow 好了.</li><li>GG Flow 的過程需要開發人員需要透過 <strong>Pull Request</strong> 將修改推送給產品 </li><li>擁有權限 Merge Pull Request 的成員被叫作 Reviewer</li><li>Reviewer 通常由較資深人員或部門主管擔任,所以通常有比較多的<del>無用</del>會議要開</li><li>Reviewer 在 Merge 之前需要作 <strong>Code Review</strong></li><li>Reviewer 需要遵循 <strong>Coding Standard</strong> 作 Code Review</li></ol><h2 id="實務面臨的問題與副作用"><a href="#實務面臨的問題與副作用" class="headerlink" title="實務面臨的問題與副作用"></a>實務面臨的問題與副作用</h2><h4 id="Coding-Standard-並不能考慮到所有狀況"><a href="#Coding-Standard-並不能考慮到所有狀況" class="headerlink" title="Coding Standard 並不能考慮到所有狀況"></a>Coding Standard 並不能考慮到所有狀況</h4><ol><li>所以 Reviewers 會定期針對不同的狀況開會討論 Coding Standard<ul><li>Coding Standard 會<strong>不定期改變</strong> , 但是透過Reviewer佈達的方式,讓第一線的RD其實難以知道其全貌.</li><li>Coding Standard 改變後不會全面的翻改程式,實務上是作到哪裡改到哪裡</li><li>以上兩點導致 Source Code 裡面有很多符合不同時期的 Coding Standard 的 Code</li><li>任一個時間點, 誰都無法保証完全符合最新的 Coding Standard </li></ul></li><li>人性,開發者會<del>COPY/PASTE 方法開發</del>參考Legacy Code開發<ul><li>Legacy Code 不符合新的 Coding Standard</li><li>Reviewer 也是人, 所以 Code Review 時也會疏漏,而 Merge 進去不符合新的 Coding Standard 的 Code</li><li>所以 Source Code 裡面還是有很多不同時期的 Coding Standard 的 Code</li></ul></li><li>回歸一開始的問題 Coding Standard 並不能考慮到所有狀況 <ul><li>還沒有開會前, 不同的 Reviewer 會有不同的想法</li><li>開會後,在執行Code Review時, 不同的 Reviewer 會有不同的作法</li><li>當一個 PR 有多人 Reviewer 時, 會有不同的意見 PR 因此被延遲 Merge</li><li>結果,<strong>交付會變慢</strong>.</li></ul></li></ol><h2 id="反思-標準還是風格？"><a href="#反思-標準還是風格？" class="headerlink" title="反思,標準還是風格？"></a>反思,標準還是風格？</h2><p>思考一下,開發程式碼的目標與價值是什麼 ?<br>寫出 Clearn Code ?<br>還是交付產品 ?<br>這樣子的 Source Code 真的是 Clearn Code 嗎？</p><h2 id="自問自答"><a href="#自問自答" class="headerlink" title="自問自答"></a>自問自答</h2><h4 id="Q1-我們該有標準嗎？"><a href="#Q1-我們該有標準嗎？" class="headerlink" title="Q1. 我們該有標準嗎？"></a>Q1. 我們該有標準嗎？</h4><p>A1. 當然要有標準,不過標準之所以為標準,應該有以下幾個特點. </p><ul><li>它應該要很簡單, 像是Class與欄位的命名規則</li><li>它應放諸四海皆準, 不應該輕易被修改</li><li>它應該可以被自動化的檢測<br>假設能作到這3點, 這件事應該可以被自動化工具處理掉 . </li></ul><h4 id="Q2-實務上就是很複雜-所以才需要討論制訂標準啊"><a href="#Q2-實務上就是很複雜-所以才需要討論制訂標準啊" class="headerlink" title="Q2. 實務上就是很複雜, 所以才需要討論制訂標準啊"></a>Q2. 實務上就是很複雜, 所以才需要討論制訂標準啊</h4><p>A2.<br>在實務上遇到很複雜的情況, 大多需要依賴約定成俗方式規範.<br>這是一種<strong>風格</strong>或<strong>原則</strong> ;<br>簡單的分類方法,<br>如果無法透過自動化工具作檢測,<br>就不應該歸類為<strong>標準</strong>.</p><p><em>註:有機會再介紹自動化的檢測工具</em></p><h4 id="Q3-風格或原則跟標準有何不同？"><a href="#Q3-風格或原則跟標準有何不同？" class="headerlink" title="Q3. 風格或原則跟標準有何不同？"></a>Q3. <strong>風格</strong>或<strong>原則</strong>跟<strong>標準</strong>有何不同？</h4><p>A3. 如上所說,標準應該能被自動化,<br>風格應該是團隊的文化自然形成的產物,<br>具體的實作可以透過讓開發者<strong>彼此之間作代碼審核</strong><br>或是<strong>結對編程</strong>培養出屬於團隊的風格,<br>風格要基於標準之上,但是不能違反原則;</p><p>以下的原則可以作為參考</p><ul><li>可以建置並通過測試</li><li>可讀性<ul><li>self documenting</li><li>有用的註解 </li></ul></li><li>公開方法要可以被測試<ul><li>小心使用靜態類別</li><li>注意new Instance的時機</li><li>重複的代碼應重構</li></ul></li><li>保持 SOLID </li></ul><p>初期的可能會發生在「{」要不要換行之類的問題上揪結之類的蠢事,<br>如果可以自動化,就把它作成標準吧…<br>如果不行的話, 就別揪結了.  </p><p>實務上可能遇到各種狀況,<br>把Reviewer的權限下放到各個開發者身上,<br>或是使用結對編程,<br>就讓團隊成員去討論與決定風格.  </p><p>以標準為根基,原則為天,<br>踩穩腳步,不要超出天空,<br>就讓團隊自由發揮吧. </p><p><strong>最後,持續交付會比每兩周花一個小時開會決定Style的細節好多了. 不是嗎？</strong></p><h2 id="其它團隊分享的具體作法"><a href="#其它團隊分享的具體作法" class="headerlink" title="其它團隊分享的具體作法"></a>其它團隊分享的具體作法</h2><ol><li>超過一定時間就讓成員擁Merge權限</li><li>Release權限仍集中控管</li><li>錯了再改就好(保持敏捷)</li><li>給pair作code review與merge (避免一人思維陷井)</li><li>兩個人無法解決時找第三方</li><li>release 功能 優先於 一致的 coding standard</li><li>品質由測試管控而非 reviewer</li><li>先有測試才有重構</li><li>可讀性 優於 枝微末節的coding standard實踐</li><li>善用自動化工具( sonarqube / stylecop )</li></ol><p>(fin)</p><h5 id="補充-社群觀點"><a href="#補充-社群觀點" class="headerlink" title="補充 社群觀點"></a>補充 <a href="https://www.facebook.com/groups/616369245163622/permalink/1225873964213144/" target="_blank" rel="noopener">社群觀點</a></h5><ul><li>coding style一般不管的。</li><li>class name／variable name，一定要叫有意義的名字。</li><li>local scope variable，換多少行，indentation，這些是小事</li><li>一個成熟的developer，隨時會被上司命令這些遠古火星文明（legacy system）去做考古工作</li><li>coding style這些事，就像emacs和vim之戰一樣，戰到skynet出來了也不會戰完的</li><li>如果要開會去討論coding style，最終很可能讓團隊口服心不服地去跟隨我的Coding Style。</li><li>在Coding Style這種低層次的小事上用光了團隊成員之間互相容忍的能量，而在更重要的大事上無法好好合作。</li><li>有很多事是比Coding Style重要的。<ul><li>Object Modeling是否跟business logic一致？</li><li>還是Object有這個attribute但是根本沒在用？</li><li>Code Change是否有做好測試？</li><li>系統架構是否合理</li><li>有做好High-Avalibility嗎？</li><li>有沒有Race Condition？</li></ul></li><li>是其是，非其非。真正有道理的，你說了對方便自然會聽下去。</li><li>「Senior」是代表自己在專業上懂得比別人多，而不是比別人身份高級。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;Coding-Standard-Code-Review-Pull-Request-amp-Delivery&quot;&gt;&lt;a href=&quot;#Coding-Standard-Code-Review-Pull-Request-amp-Delivery&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="Coding Standard" scheme="http://blog.marsen.me/tags/Coding-Standard/"/>
    
  </entry>
  
  <entry>
    <title>一年後的我想要什麼？</title>
    <link href="http://blog.marsen.me/2018/01/01/2018/next_year/"/>
    <id>http://blog.marsen.me/2018/01/01/2018/next_year/</id>
    <published>2017-12-31T18:12:47.000Z</published>
    <updated>2018-04-17T03:12:39.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="你的目標是什麼"><a href="#你的目標是什麼" class="headerlink" title="你的目標是什麼?"></a>你的目標是什麼?</h2><p><strong>自由</strong></p><p>什麼是自由？</p><ol><li>情感上的自由</li><li>時間上的自由</li><li>經濟上的自由</li></ol><h2 id="經濟上的自由是一切的基礎"><a href="#經濟上的自由是一切的基礎" class="headerlink" title="經濟上的自由是一切的基礎"></a>經濟上的自由是一切的基礎</h2><ol><li>更多的收入 <ol><li>被動的收入</li><li>更高的薪資</li></ol></li><li>更有成就感的工作<ol><li>被同事尊重</li><li>被上司認可</li><li>受人歡迎</li></ol></li><li>更多的選擇<ol><li>技術提昇</li><li>領域擴展</li><li>人脈</li></ol></li><li>健康的身體</li><li>更多享受生活</li></ol><h2 id="一年後的我想要什麼"><a href="#一年後的我想要什麼" class="headerlink" title="一年後的我想要什麼?"></a>一年後的我想要什麼?</h2><p>一年後的我想要什麼?</p><ol><li>更高的薪資<ol><li>維持現狀 K (x)</li><li>跳糟 K * 1.3 (x)</li><li>爭取加薪 K * 1.1</li><li>獎金與分紅 </li></ol></li><li>更有成就感的工作(什麼是成就感)？    <ol><li>擁有可以引以為豪的產品<ol><li>拆解單體為服務導向</li><li>架構升級        </li></ol></li><li>分享與教學<pre><code>1. Blog2. 內/外部sharing3. 單元測試導入        </code></pre></li></ol></li><li>更多的選擇<ol><li>技術轉移<ol><li>Web 技術 轉移 為 Service導向技術</li><li>container 技術</li><li>cloud 技術        </li></ol></li><li>技術提昇<ol><li>.Net </li><li>Infra</li><li>Domain know how</li></ol></li></ol></li></ol><h3 id="爭取加薪-K-1-1"><a href="#爭取加薪-K-1-1" class="headerlink" title="爭取加薪 K * 1.1"></a>爭取加薪 K * 1.1</h3><h2 id="而這些目標需要什麼才能爭取到"><a href="#而這些目標需要什麼才能爭取到" class="headerlink" title="而這些目標需要什麼才能爭取到?"></a>而這些目標需要什麼才能爭取到?</h2><p>分為三個面向,技術提昇、技術擴展與自我實現,  </p><h3 id="技術提昇"><a href="#技術提昇" class="headerlink" title="技術提昇"></a>技術提昇</h3><p>首先目前我擁有的技術能力有</p><ol><li>.Net solution的 Web Developer能力</li><li>同時兼顧有 DB 與 F2E 基礎進階能力 </li></ol><p>這與我過去的選擇有關, 一直以來都在 Web 深入研究<br>未來的一年仍要朝這個方向發展.<br>但是會改由 Web 導向轉變成服務導向,<br>而 Web 開發只是我本身所能提供給公司的一個服務而已,<br>跟著 .Net 的腳步我想把前台(包含大馬但不限於)昇級上一個版本,<br>包含目前使用的舊版 libary 與 Framework,<br>如此一來可以使用到新版 .Net 的語法,<br>同時也可以解開一些導入測試與微服務時遇到的困境.  </p><h3 id="現有能力列表"><a href="#現有能力列表" class="headerlink" title="現有能力列表"></a>現有能力列表</h3><ol><li>C# &amp; .Net Framework Solution (inculde Linq &amp; Entity Framework )</li><li>javascript (jQuery &amp; Angular etc..)</li><li>Database with Sql (MsSQL solution)</li><li>Source Controle (Git)</li><li></li></ol><h3 id="略懂"><a href="#略懂" class="headerlink" title="略懂"></a>略懂</h3><ol><li>nodejs (with expressjs) &amp; php(codeigniter) &amp; ruby (RoR)</li><li>Jenkins</li><li></li></ol><h3 id="技術的擴展"><a href="#技術的擴展" class="headerlink" title="技術的擴展"></a>技術的擴展</h3><p>我認為公司的單體架構已經面臨到不得不拆的狀況,<br>公司也有意朝這個方向走那是最好不過的了,<br>但對現存的.NET 開發者而言,我認為人人都要有危機意識<br>我看到的現象</p><ol><li>頁面會被CMS取代</li><li>大部份的API可以被Lambda取代</li><li>主流程的部份在跨國的目標下會逐步變成微服務</li></ol><p>基於以上幾點, 除了.Net 的 solution 外,<br>更多情況是要使用別的 solution 或是混用,<br>對此我的視野必須有所提昇,  </p><ol><li>Linux Bash</li><li>Container 技術</li><li>Cloud (AWS/Azure/GCP)</li><li>Node.js<br>在未來的一年開發流程或是維運流程會有很大很快的變化<br>要多聽多看多想多問,公司有很多人才要儘可能的跟他們學習.  </li></ol><h3 id="自我營銷"><a href="#自我營銷" class="headerlink" title="自我營銷"></a>自我營銷</h3><p>最後是自我實現的部份,<br>自我營銷是我很弱的一部份,<br>不善交際,不喜歡人群<br>這點我從去年就開始調整,<br>多參與公司內部的分享,不要害怕說錯<br>假裝自已是對的,再虛心接受別人的指點<br>不需要導師,因為人人都是我的導師<br>開始寫Blog並且貼到社群網站給人鞭<br>這是我目前的 <a href="https://blog.marsen.me">https://blog.marsen.me</a></p><p>今年會繼續朝這個方向衝刺.<br>多分享 多犯錯 然後接受反饋學習.<br>兩個部份是我可以練習分享的機會<br>一個是測試的導入,<br>我們的遺留代碼,有很多可以分享的部份,<br>二是讀書會,<br>借由讀書會可以練習分享,<br>同時學習別人怎麼分享,<br>並且看完一本書,一舉數得.  </p><h2 id="具體主管可以幫助我的部份"><a href="#具體主管可以幫助我的部份" class="headerlink" title="具體主管可以幫助我的部份"></a>具體主管可以幫助我的部份</h2><ol><li>加薪(沒有比這個更務實的了)</li><li>明確指出我的錯誤或是作的好的部份</li></ol><p>Do more do faster </p><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;你的目標是什麼&quot;&gt;&lt;a href=&quot;#你的目標是什麼&quot; class=&quot;headerlink&quot; title=&quot;你的目標是什麼?&quot;&gt;&lt;/a&gt;你的目標是什麼?&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;自由&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什麼是自由？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;情
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2017年的學習回顧與展望</title>
    <link href="http://blog.marsen.me/2018/01/01/2018/2017_learned/"/>
    <id>http://blog.marsen.me/2018/01/01/2018/2017_learned/</id>
    <published>2017-12-31T16:00:51.000Z</published>
    <updated>2018-04-17T03:12:39.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><p>參加了兩個活動,分別是<a href="https://blog.marsen.me/2017/04/23/unitestwriting/">單元測試這樣玩就對了</a>,與<a href="https://blog.marsen.me/2017/05/19/testingislearning/">測試即學習</a>;  </p><h3 id="單元測試這樣玩就對了"><a href="#單元測試這樣玩就對了" class="headerlink" title="單元測試這樣玩就對了"></a><a href="https://blog.marsen.me/2017/04/23/unitestwriting/">單元測試這樣玩就對了</a></h3><p>最大的收獲是突破了寫測試的心魔, 在那之前總覺得 TDD 只是口號, 或是烏托邦的開發理想.<br>雖然之前也有花大錢出外受訓, 或是公司內部的內訓.<br>手上也有一些前輩的測試代碼, 但是就是沒有「感覺」,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不過仍然感謝前幾年的自已有將資源花在測試上面,  </span><br><span class="line">累積了兩年的測試經驗,  </span><br><span class="line">融會貫通卻只是一瞬間的事</span><br></pre></td></tr></table></figure></p><p>最主要是講者展現了實務上面的需求與改進,<br>過去寫的加法運算, 或是<a href="https://zh.wikipedia.org/wiki/猜單詞遊戲" target="_blank" rel="noopener">吊人遊戲</a>,<br>雖然也是從無到,也是先寫測試,<br>但或許是太過強調 TDD 太過強調從無到有<br>總與實際開發經驗相違背,<br>講者在過程中一句 <strong>「不要管先寫測試還是程式」</strong><br>反而更貼近真實,先寫程式,再想想怎麼測試？<br>為了測試, 再重構, 逐步分解的過程令我大開眼界.  </p><p>過去曾與人討論過TDD的議題,<br>總會得到「實務與理論有差別」、「其背景與環境因素不能寫測試」<br>這類似是而非的回答,當下我也無法辯駁<br>現在想起來只能莞爾. </p><p>測試趨動開發不等於一定要先測試,<br>特別是習慣於先寫產品程式的人,<br>不仿先寫產品程式, 再寫測試而趨動重構<br>當寫習慣了,知道哪些耦合會帶來重構的代價時,<br>再寫一次就人性就會自動迴避這些不好的Patten .</p><p>別管順序,但是記得寫測試.</p><h3 id="測試即學習"><a href="#測試即學習" class="headerlink" title="測試即學習"></a><a href="https://blog.marsen.me/2017/05/19/testingislearning/">測試即學習</a></h3><p>梅老師的課也是很毀三觀的,<br>老實說我跟本不知道他在幹嘛,<br>塔羅牌拿出來的時候,<br>我真的以為是<a href="https://zh.wikipedia.org/wiki/郭美江傳道爭議事件#%E5%BD%B1%E7%89%87%E4%BB%A5%E5%A4%96%E4%B9%8B%E5%BD%B1%E9%9F%BF" target="_blank" rel="noopener">美江</a>再現(那個時候<a href="https://goo.gl/zD51h3" target="_blank" rel="noopener">Seafood</a>還沒有業力引爆( ･ω･)( ･ω･)( ･ω･))<br>那堂課的目標族群應該是QA,<br>不過這個時代不應自我設限,<br>複習一下梅老師的分享,  </p><p>探索測試</p><ul><li>儘可能的發散</li><li>摹仿別人看事情的角度</li><li>有意識的學習(mindful learning)<ul><li>記錄</li><li>總結</li><li>歸納問題的核心</li><li>給它起一個名字(沒有專有名詞的話)</li><li>有意識的逃離第一印象</li><li>小心不經意的盲區(inattentional blindness)</li><li>數量 X 練習 X 思考 X 學習 = 提昇</li></ul></li></ul><p>對我來說,<strong>給它起一個名字</strong>真是超級有用的,<br>新認識的朋友就叫作「王大棰」, 新的技術就叫「起司包」, 新的概念就叫「黑盒子」等…<br>不要過於專研於名詞, 用自已能理解的名字去框那個新事物的範圍,<br>最後再把名字用大家通用的名字取代掉就好了.<br>看了很多的方法論,會發現其實觀念沒什麼改變,<br>只是新的名詞會一直冒出來,<br>唯物主義、馬基維利主義、不擇手段、實用主義<br>改善、KANBAN、敏捷、精實  balabala…</p><h2 id="“没有时间”-完美的借口"><a href="#“没有时间”-完美的借口" class="headerlink" title="“没有时间”- 完美的借口"></a><a href="http://www.danielteng.com/2012/09/25/no-time-to-learn-perfect-excuse/" target="_blank" rel="noopener">“没有时间”- 完美的借口</a></h2><p>2017年影響我最深的一篇Blog,<br>2012年的文章, 篇幅也不長,<br>觀念也很簡單, 作就對了, 作壞了就丟掉再作一次,<br>很多的書都要我們刻意練習,<br>但是我們的時間哪有那麼多呢？<br>長大了之後,才來1萬小時的修練是不是太晚了呢？  </p><p>下半年公司開始推行測試,<br>基層的工程師們其實反彈的聲音一直都在,<br>雖然一直有教育訓練與培養種子,<br>不過大多淪為口號的狀態,<br>我也只能用這篇文章作為勉勵.  </p><p>其實現在的版本控制系統已經非常便利,<br>要建立一個Sandbox的分支,<br>在裡面嚐試各種可能性是非常容易的,<br>作壞了丟掉分支就好了,<br>身為專業的工程人員,測試是必須的,失敗也是,<br>在沙箱內失敗,其實是摔不疼的,勇敢嚐試吧. </p><h2 id="生產力"><a href="#生產力" class="headerlink" title="生產力"></a>生產力</h2><p>2016年是時間記錄的一年,<br>那2017年就是把記錄的時間,<br>轉換成生產力的一年.<br>幾本影響比較多的書,不過或許我仍需要二讀至三讀以上</p><ul><li>最有生產力的一年 → 時間X精力X專注力 = 生產力</li><li>GTD → 下一步要作什麼？</li><li>軟技能 → 自我營銷</li></ul><p>新的一年重心會放在習慣上面,<br>因為讓習慣趨動行為,<br>比起刻意遵循某些方法要好得多,<br>「刻意」太浪費精神力了,<br>下一步會如何呢？<br>希望能翻轉自已</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>順利的帶媽媽出國了,或許對一些人來說不算什麼成就吧,<br>新的一年有些機會,去日本、以色列、俄羅斯、馬來西亞,<br>雖然八字還沒有一撇, 但至少會去一個地方吧…<br>其他的地方就只能見機行事了.</p><p>新年快樂<br>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;測試&quot;&gt;&lt;a href=&quot;#測試&quot; class=&quot;headerlink&quot; title=&quot;測試&quot;&gt;&lt;/a&gt;測試&lt;/h2&gt;&lt;p&gt;參加了兩個活動,分別是&lt;a href=&quot;https://blog.marsen.me/2017/04/23/unitestwriting/&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Visual Studio 2017 MSTest Framework 異常修正</title>
    <link href="http://blog.marsen.me/2017/12/11/test_learn/vs2017_mstest_with_nuget/"/>
    <id>http://blog.marsen.me/2017/12/11/test_learn/vs2017_mstest_with_nuget/</id>
    <published>2017-12-11T03:17:08.000Z</published>
    <updated>2018-04-17T03:12:39.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="應該要知道的事"><a href="#應該要知道的事" class="headerlink" title="應該要知道的事"></a>應該要知道的事</h2><ul><li>這是踩雷筆記</li><li>2017的筆記可能會隨時間變得沒有參考價值</li><li>Visual Studio 2017的問題,並不一定適用其他版本</li></ul><h2 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h2><p><img src="https://i.imgur.com/FDDtc9V.jpg" alt="載入測試時發生例外狀況"><br>原本使用 Visual Studio 2015 建立的測試專案,<br>升級到 Visual Studio 2017 後, 發生以下錯誤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[2017/12/11 上午 02:09:59 Error] 測試探索程式 &apos;SpecRunTestDiscoverer&apos; </span><br><span class="line">載入測試時發生例外狀況。例外狀況: 無法載入檔案或組件 </span><br><span class="line">&apos;Microsoft.VisualStudio.QualityTools.UnitTestFramework,</span><br><span class="line">Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&apos;</span><br><span class="line">或其相依性的其中之一。 系統找不到指定的檔案。</span><br></pre></td></tr></table></figure></p><h2 id="導致結果"><a href="#導致結果" class="headerlink" title="導致結果"></a>導致結果</h2><p><img src="https://i.imgur.com/2REPRzG.jpg" alt="原本的測試數量為1942,變成459,遺失了7成5的測試案例."></p><ol><li>測試專案會找不到測試,或是測試數量不正確.</li><li>可以使用 Visual Studio 2015 重新執行探測索測試,即可排除問題.</li></ol><h2 id="VS2015-已移除或未安裝該怎麼辦？"><a href="#VS2015-已移除或未安裝該怎麼辦？" class="headerlink" title="VS2015 已移除或未安裝該怎麼辦？"></a>VS2015 已移除或未安裝該怎麼辦？</h2><p>透過MsTest直接加入<br><code>Microsoft.VisualStudio.QualityTools.UnitTestFramework</code><br>的參考已經是舊的方法了, </p><h4 id="在-vs2017-建議的解決方案如下"><a href="#在-vs2017-建議的解決方案如下" class="headerlink" title="在 vs2017 建議的解決方案如下:"></a>在 vs2017 建議的解決方案如下:</h4><ul><li>移除方案中所有對 <code>Microsoft.VisualStudio.QualityTools.UnitTestFramework</code> 的參考</li><li>透過 Nuget 安裝 MSTest.TestAdapter </li><li>透過 Nuget 安裝 MSTest.TestFramework</li><li>關閉 vs2017</li><li>移除 <code>%temp%\VisualStudioTestExplorerExtensions</code>內所有檔案</li><li>重啟 vs2017 並建置以觸發探索測試<br><img src="https://i.imgur.com/RPI77KN.jpg" alt="透過 Nuget 安裝 MSTest.TestAdapter/MSTest.TestFramework"><br><img src="https://i.imgur.com/JQ7zf2S.jpg" alt="重啟 vs2017 並建置以觸發探索測試"></li></ul><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://developercommunity.visualstudio.com/content/problem/14673/unit-test-fail-cannot-load-microsoftvisualstudiote.html" target="_blank" rel="noopener">Unit test fail - cannot load Microsoft.VisualStudio.TestPlatform.TestFramework.Extensions</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;應該要知道的事&quot;&gt;&lt;a href=&quot;#應該要知道的事&quot; class=&quot;headerlink&quot; title=&quot;應該要知道的事&quot;&gt;&lt;/a&gt;應該要知道的事&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;這是踩雷筆記&lt;/li&gt;
&lt;li&gt;2017的筆記可能會隨時間變得沒有參考價值&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="MsTest" scheme="http://blog.marsen.me/tags/MsTest/"/>
    
      <category term="Visual Studio" scheme="http://blog.marsen.me/tags/Visual-Studio/"/>
    
  </entry>
  
  <entry>
    <title>單元測試與重構記錄(二) 發問篇</title>
    <link href="http://blog.marsen.me/2017/12/08/test_learn/integrated_testing_partice2_question/"/>
    <id>http://blog.marsen.me/2017/12/08/test_learn/integrated_testing_partice2_question/</id>
    <published>2017-12-08T11:04:42.000Z</published>
    <updated>2018-04-17T03:12:39.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q1-Controller-要測試嗎？"><a href="#Q1-Controller-要測試嗎？" class="headerlink" title="Q1 Controller 要測試嗎？"></a>Q1 Controller 要測試嗎？</h2><h3 id="Logics-in-controller"><a href="#Logics-in-controller" class="headerlink" title="Logics in controller"></a>Logics in controller</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="meta-string">"Member/Get/&#123;Id&#125;"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonResult <span class="title">GetMemeberList</span>(<span class="params"><span class="keyword">long</span> Id, <span class="keyword">string</span> cc = <span class="string">"f"</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cleanCache = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/ logics here</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.IsFromCompany() &amp;&amp; cc == <span class="string">"t"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/ do something ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> memeberList = <span class="keyword">this</span>.memeberService.GetmemeberList(Id, cleanCache);            </span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/ logics here</span></span><br><span class="line">        <span class="keyword">if</span> (memeberList.Any())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment"><span class="doctag">///</span>/ do something ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment"><span class="doctag">///</span>/ do something ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.Json(result, JsonRequestBehavior.AllowGet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/ logics here</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/ do something ...                </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自問自答"><a href="#自問自答" class="headerlink" title="自問自答"></a>自問自答</h4><p>我認為要，<br>但是對於WebAPI回傳的<code>JsonResult</code>或是<code>ActionResult</code><br>需要轉形才能作驗証<br>可以考慮整合測試勝於單元測試,<br>Controller的通常是面對 Client Side 的呼叫.</p><h2 id="Q2-當-Controller-只有取資料的邏輯"><a href="#Q2-當-Controller-只有取資料的邏輯" class="headerlink" title="Q2 當 Controller 只有取資料的邏輯"></a>Q2 當 Controller 只有取資料的邏輯</h2><h3 id="No-Logics-in-Controller"><a href="#No-Logics-in-Controller" class="headerlink" title="No Logics in Controller"></a>No Logics in Controller</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">Index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.Service.GetIndex();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Q3-當-Service-只有取資料的邏輯"><a href="#Q3-當-Service-只有取資料的邏輯" class="headerlink" title="Q3 當 Service 只有取資料的邏輯"></a>Q3 當 Service 只有取資料的邏輯</h2><h3 id="No-Logics-in-Service"><a href="#No-Logics-in-Service" class="headerlink" title="No Logics in Service"></a>No Logics in Service</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Member <span class="title">Get</span>(<span class="params"><span class="keyword">long</span> id</span>)</span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.DataAccessor.GetMember(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自問自答-1"><a href="#自問自答-1" class="headerlink" title="自問自答"></a>自問自答</h4><p>我認為不要,<br>要測試商業邏輯,不要在意覆蓋率</p><h2 id="Q4-當Service只有取Catch資料的邏輯"><a href="#Q4-當Service只有取Catch資料的邏輯" class="headerlink" title="Q4. 當Service只有取Catch資料的邏輯"></a>Q4. 當Service只有取Catch資料的邏輯</h2><h3 id="No-Logics-in-Service-just-call-another-service"><a href="#No-Logics-in-Service-just-call-another-service" class="headerlink" title="No Logics in Service , just call another service"></a>No Logics in Service , just call another service</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Member <span class="title">Get</span>(<span class="params"><span class="keyword">long</span> id</span>)</span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> enableCache = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">this</span>.CacheService.GetCacheData(</span><br><span class="line">        cacheKey,</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.DataAccessor.GetMember(id);</span><br><span class="line">        &#125;,</span><br><span class="line">        enableCache</span><br><span class="line">    );    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自問自答-2"><a href="#自問自答-2" class="headerlink" title="自問自答"></a>自問自答</h4><p>同上,仍然不需要,<br>要測試商業邏輯,不要在意覆蓋率,<br>要注意的或許是<code>CacheService.GetCacheData</code>是不是有包測試 ?<br>一般來說,Cache的功能很泛用,測試的報酬率很高</p><h2 id="Q5-承上-當邏輯存在Func參數之中？"><a href="#Q5-承上-當邏輯存在Func參數之中？" class="headerlink" title="Q5. 承上,當邏輯存在Func參數之中？"></a>Q5. 承上,當邏輯存在Func參數之中？</h2><h3 id="Logics-in-Func"><a href="#Logics-in-Func" class="headerlink" title="Logics in Func"></a>Logics in Func</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Member <span class="title">Get</span>(<span class="params"><span class="keyword">long</span> id</span>)</span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> enableCache = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">this</span>.CacheService.GetCacheData(</span><br><span class="line">        cacheKey,</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">            <span class="comment"><span class="doctag">///</span>/ logics here</span></span><br><span class="line">            <span class="keyword">if</span>(id &gt; <span class="number">9487</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.MemberAccessor.GetMember(id);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.MemberV2Accessor.GetMember(id);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        enableCache</span><br><span class="line">    );    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自問自答-3"><a href="#自問自答-3" class="headerlink" title="自問自答"></a>自問自答</h4><p>暫時無解,<br>或許是這樣Pattern不適合測試,需要調整架構嗎？<br>為了測試多包成一個公開方法,反而失去匿名函數的彈性優點,<br>不在匿名函數內寫邏輯更不合理,待求解答</p><h2 id="Q6-當邏輯在DA層或ORM的Query中要如何測試？"><a href="#Q6-當邏輯在DA層或ORM的Query中要如何測試？" class="headerlink" title="Q6.當邏輯在DA層或ORM的Query中要如何測試？"></a>Q6.當邏輯在DA層或ORM的Query中要如何測試？</h2><h3 id="Logics-in-ORM"><a href="#Logics-in-ORM" class="headerlink" title="Logics in ORM"></a>Logics in ORM</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">上略...</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> transactionScope = <span class="keyword">new</span> TransactionScope(TransactionScopeOption.Required, transactionOptions))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Entities context = Entities.CreateNew(isReadOnly: <span class="literal">true</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/ logics here</span></span><br><span class="line">        <span class="keyword">var</span> query = <span class="keyword">from</span> a <span class="keyword">in</span> context.Activies.Valids()</span><br><span class="line">                    <span class="keyword">where</span> a.Activies_StartDateTime &lt;= startTime &amp;&amp;</span><br><span class="line">                    a.Activies_EndDateTime &gt;= now &amp;&amp;</span><br><span class="line">                    a.Activies_ShopId == shopId &amp;&amp;</span><br><span class="line">                    a.ActiviesCondition.Any(i =&gt; i.Activies_ValidFlag</span><br><span class="line">                    &amp;&amp; TypeList.Contains(i.Activies_TypeDef))                    </span><br><span class="line">                    <span class="keyword">select</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自問自答-4"><a href="#自問自答-4" class="headerlink" title="自問自答"></a>自問自答</h4><p>不適用單元測試,應該整合測試作包覆</p><h2 id="Q7-當邏輯在MappingProfile該如何測試"><a href="#Q7-當邏輯在MappingProfile該如何測試" class="headerlink" title="Q7. 當邏輯在MappingProfile該如何測試?"></a>Q7. 當邏輯在MappingProfile該如何測試?</h2><h3 id="Logics-in-MappingProfile"><a href="#Logics-in-MappingProfile" class="headerlink" title="Logics in MappingProfile"></a>Logics in MappingProfile</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mapper.CreateMap&lt;PageEntity, UserPageEntity&gt;()</span><br><span class="line">  .ForMember(i =&gt; i.Id, s =&gt; s.MapFrom(i =&gt; i.User_Id))</span><br><span class="line">  .ForMember(i =&gt; i.Title, s =&gt; s.MapFrom(i =&gt; i.User_Name))</span><br><span class="line">  .ForMember(i =&gt; i.PageName, s =&gt; s.MapFrom(i =&gt; i.User_Name + i.User_LastName))</span><br><span class="line">  .ForMember(i =&gt; i.LightBox, s =&gt; s.MapFrom(i =&gt; i.User_Sex == <span class="string">"male"</span> ? <span class="literal">true</span> : <span class="literal">false</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自問自答-5"><a href="#自問自答-5" class="headerlink" title="自問自答"></a>自問自答</h4><p>要作測試,檢查欄位Mapping是否正確,<br>但實務上若重用性不高,寫MappingProfile不如直接在代碼內轉換.<br>可以少寫MappingProfile的測試.</p><p>待解答…<br>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Q1-Controller-要測試嗎？&quot;&gt;&lt;a href=&quot;#Q1-Controller-要測試嗎？&quot; class=&quot;headerlink&quot; title=&quot;Q1 Controller 要測試嗎？&quot;&gt;&lt;/a&gt;Q1 Controller 要測試嗎？&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
    
      <category term="Unit Testing" scheme="http://blog.marsen.me/tags/Unit-Testing/"/>
    
      <category term="Integrated Testing" scheme="http://blog.marsen.me/tags/Integrated-Testing/"/>
    
  </entry>
  
  <entry>
    <title>[學習筆記]AWS EC2開機筆記</title>
    <link href="http://blog.marsen.me/2017/12/08/cloud_learn/aws_creat_ec2_instance/"/>
    <id>http://blog.marsen.me/2017/12/08/cloud_learn/aws_creat_ec2_instance/</id>
    <published>2017-12-08T08:42:42.000Z</published>
    <updated>2018-04-17T03:12:39.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="應該知道的事"><a href="#應該知道的事" class="headerlink" title="應該知道的事"></a>應該知道的事</h2><ul><li>這個是教育訓練的筆記</li><li>使用web console 建立ec2</li><li>使用cli 建立ec2</li><li>2017的筆記可能會隨時間變得沒有參考價值</li><li>關鍵參數都打馬賽克,沒有牽扯到EBS/S3/VPC</li><li>對你可能沒有幫助</li></ul><h2 id="Web-Console"><a href="#Web-Console" class="headerlink" title="Web Console"></a>Web Console</h2><ol><li><p>login AWS</p></li><li><p>進入EC2<br><img src="https://i.imgur.com/hRFwjzr.jpg" alt=""></p></li><li><p>Launch Instance<br><img src="https://i.imgur.com/g9vlacA.jpg" alt=""></p></li><li><p>選擇AMI(Amazon Machine Image )<br><img src="https://i.imgur.com/dVKPsAp.jpg" alt=""></p></li><li><p>選擇Instance Type(有錢隨便選,沒錢選t2.nano)<br><img src="https://i.imgur.com/61gG2pd.jpg" alt=""></p></li><li><p>設定 Instance Details<br><img src="https://i.imgur.com/NkbKrzL.jpg" alt=""></p></li><li><p>如果想在開機的時候自動安裝一些程式,可以在<code>Advanced Details</code> 加語法<br>windows AMI請用 <code>Powershell</code><br><img src="https://i.imgur.com/bJxWlgd.jpg" alt=""></p></li><li><p>加硬碟<br><img src="https://i.imgur.com/MP9igLc.jpg" alt=""></p></li><li><p>加tag<br><img src="https://i.imgur.com/xDTx2nv.jpg" alt=""></p></li><li><p>設定Configure Security Group<br><img src="https://i.imgur.com/wximWw1.jpg" alt=""></p></li><li><p>預覽與啟動<br><img src="https://i.imgur.com/6Y4fcOI.jpg" alt=""></p></li><li><p>最後一步,選擇key-pair<br><img src="https://i.imgur.com/fRhUafI.jpg" alt=""></p></li></ol><h2 id="CLI-command"><a href="#CLI-command" class="headerlink" title="CLI command"></a>CLI command</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aws ec2 run-instances --image-id ami-da9e2cbc --count 1 --instance-type t2.nano --subnet-id subnet-cxxxxxxx --user-data file://userdata.sh --tag-specifications &quot;ResourceType=instance,Tags=[&#123;Key=Environment,Value=AWS-Training&#125;,&#123;Key=Name,Value=AWS-Training_MarkLin&#125;]&quot; --security-group-ids sg-XXXXXX --key-name marktest.japan.training</span><br></pre></td></tr></table></figure><h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul><li><a href="http://docs.aws.amazon.com/cli/latest/reference/ec2/run-instances.html" target="_blank" rel="noopener">run-instances</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;應該知道的事&quot;&gt;&lt;a href=&quot;#應該知道的事&quot; class=&quot;headerlink&quot; title=&quot;應該知道的事&quot;&gt;&lt;/a&gt;應該知道的事&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;這個是教育訓練的筆記&lt;/li&gt;
&lt;li&gt;使用web console 建立ec2&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="AWS" scheme="http://blog.marsen.me/tags/AWS/"/>
    
      <category term="EC2" scheme="http://blog.marsen.me/tags/EC2/"/>
    
  </entry>
  
  <entry>
    <title>單元測試與重構記錄(一)</title>
    <link href="http://blog.marsen.me/2017/10/31/integrated_testing_partice/"/>
    <id>http://blog.marsen.me/2017/10/31/integrated_testing_partice/</id>
    <published>2017-10-30T16:42:10.000Z</published>
    <updated>2018-04-17T03:12:39.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>有幸參與了一個跨國的專案,<br>為了快速上線，決定將整套原本在台灣程式碼搬移到跨國專案上,<br>上線後再依使用者的需求調整開發功能,<br>而在搬移的過程中,有需多模組並未開啟。<br>…</p><h2 id="現況"><a href="#現況" class="headerlink" title="現況"></a>現況</h2><p>遺留代碼 → 跨國 遇到的問題</p><ol><li>Copy Paste 最快卻不一定最適合</li><li>Copy Paste 最快卻不一定改得動</li><li>Copy Paste 最快但是有的地方沒Copy完</li></ol><p><code>用明朝的劍，斬清朝的官</code></p><h2 id="實務需求"><a href="#實務需求" class="headerlink" title="實務需求"></a>實務需求</h2><p>將本來跨國未開啟的<strong>折扣活動</strong>模組打開,<br>簡單的流程大致如下:<br>購物車 → 取得購物車資料 → 折扣活動 → 計算</p><p>實務上,整個流程作了許多事<br><img src="https://i.imgur.com/pM36Joo.jpg" alt=""></p><p>應該說作了太多事.<br><img src="https://i.imgur.com/NU0PqCh.jpg" alt=""></p><p>程式碼有壞味道,卻不能修改(重構).<br>因為沒有測試保護. </p><p>單一的Process，複雜度過高的方法(12)</p><p><code>CalculateShoppingCartPromotionDiscountV2Processor.Process()</code></p><p><img src="https://i.imgur.com/qleqGPb.jpg" alt=""></p><h3 id="目標與執行順序"><a href="#目標與執行順序" class="headerlink" title="目標與執行順序"></a>目標與執行順序</h3><ol><li>由 PM 或 QA 補足整合測試情境到足夠<ul><li>由實務上的需求來認定</li></ul></li><li>刪除台灣的測試</li><li>解析 <code>CalculateShoppingCartPromotionDiscountV2Processor</code> </li><li>補上單元測試<ul><li>Code Coverage(測試覆蓋率)</li></ul></li><li>重構</li></ol><h2 id="最終的目標是重構"><a href="#最終的目標是重構" class="headerlink" title="最終的目標是重構"></a>最終的目標是重構</h2><ul><li>心態:<a href="http://www.danielteng.com/2012/09/25/no-time-to-learn-perfect-excuse/" target="_blank" rel="noopener">沒有時間，完美的借口</a></li><li>重構前要先作整合測試</li><li>現有的整合測試的缺陷<ol><li>測試項目不符合馬來西亞現狀</li><li>測試項目未處理多語系</li><li>測試項目未處理小數點</li><li>測試項目難以閱讀</li><li>測試項目有重覆的覆蓋範圍</li></ol></li><li>RD與PM與QA合作</li></ul><h3 id="UAT-讓「人」讀得懂"><a href="#UAT-讓「人」讀得懂" class="headerlink" title="UAT 讓「人」讀得懂"></a>UAT 讓「人」讀得懂</h3><h4 id="原本的-UAT-RD"><a href="#原本的-UAT-RD" class="headerlink" title="原本的 UAT (RD)"></a>原本的 UAT (RD)</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">場景: case37：商品活動+全店活動(有排除)；宅配，運費50元，滿350免運</span><br><span class="line">．全店活動 / 有排除商品；滿額打折，多階(滿第1階)，跨溫層</span><br><span class="line">．折扣條件：滿199元，打95折 / 滿299元，打89折 / 滿399元，打84折</span><br><span class="line">．商品活動；滿件折現，單階，跨溫層</span><br><span class="line">．折扣條件：滿2件，折45元</span><br><span class="line">假設 購物車中溫層<span class="string">"Freezer"</span>商品為</span><br><span class="line">|<span class="string"> SalePageId </span>|<span class="string"> SaleProductSKUId </span>|<span class="string"> Price </span>|<span class="string"> Qty </span>|</span><br><span class="line">|<span class="string"> 50         </span>|<span class="string"> 50               </span>|<span class="string"> 75    </span>|<span class="string"> 1   </span>|</span><br><span class="line">|<span class="string"> 27         </span>|<span class="string"> 27               </span>|<span class="string"> 66    </span>|<span class="string"> 2   </span>|</span><br><span class="line">並且 購物車中溫層<span class="string">"Refrigerator"</span>商品為</span><br><span class="line">|<span class="string"> SalePageId </span>|<span class="string"> SaleProductSKUId </span>|<span class="string"> Price </span>|<span class="string"> Qty </span>|</span><br><span class="line">|<span class="string"> 26         </span>|<span class="string"> 26               </span>|<span class="string"> 55    </span>|<span class="string"> 2   </span>|</span><br><span class="line">並且 購物車中溫層<span class="string">"Normal"</span>商品為</span><br><span class="line">|<span class="string"> SalePageId </span>|<span class="string"> SaleProductSKUId </span>|<span class="string"> Price </span>|<span class="string"> Qty </span>|</span><br><span class="line">|<span class="string"> 25         </span>|<span class="string"> 25               </span>|<span class="string"> 2     </span>|<span class="string"> 2   </span>|</span><br><span class="line">並且 活動<span class="string">"1"</span>範圍設定為</span><br><span class="line">|<span class="string"> TargetType </span>|<span class="string"> TargetIdList </span>|</span><br><span class="line">|<span class="string"> Shop       </span>|<span class="string"> 1            </span>|</span><br><span class="line">並且 活動目標排除商品頁為</span><br><span class="line">|<span class="string"> PromotionId </span>|<span class="string"> TargetExcludeSalePageList </span>|</span><br><span class="line">|<span class="string"> 1           </span>|<span class="string"> 50          </span>|</span><br><span class="line">並且  現折活動<span class="string">"1"</span>的折扣為</span><br><span class="line">|<span class="string"> Id </span>|<span class="string"> TypeDef      </span>|<span class="string"> TotalPrice </span>|<span class="string"> DiscountTypeDef </span>|<span class="string"> DiscountRate </span>|</span><br><span class="line">|<span class="string"> 1  </span>|<span class="string"> TotalPriceV2 </span>|<span class="string"> 199        </span>|<span class="string"> DiscountRate    </span>|<span class="string"> 0.95         </span>|</span><br><span class="line">|<span class="string"> 2  </span>|<span class="string"> TotalPriceV2 </span>|<span class="string"> 299        </span>|<span class="string"> DiscountRate    </span>|<span class="string"> 0.89         </span>|</span><br><span class="line">|<span class="string"> 3  </span>|<span class="string"> TotalPriceV2 </span>|<span class="string"> 399        </span>|<span class="string"> DiscountRate    </span>|<span class="string"> 0.84         </span>|</span><br><span class="line">並且 活動<span class="string">"2"</span>範圍設定為</span><br><span class="line">|<span class="string"> TargetType        </span>|<span class="string"> TargetIdList </span>|</span><br><span class="line">|<span class="string"> PromotionSalePage </span>|<span class="string"> 0            </span>|</span><br><span class="line">並且 活動目標商品頁為</span><br><span class="line">|<span class="string"> PromotionId </span>|<span class="string"> TargetSalePageList </span>|</span><br><span class="line">|<span class="string"> 2           </span>|<span class="string"> 50,25,26,27        </span>|</span><br><span class="line">並且  現折活動<span class="string">"2"</span>的折扣為</span><br><span class="line">|<span class="string"> Id </span>|<span class="string"> TypeDef    </span>|<span class="string"> TotalQty </span>|<span class="string"> DiscountTypeDef </span>|<span class="string"> DiscountPrice </span>|</span><br><span class="line">|<span class="string"> 4  </span>|<span class="string"> TotalQtyV2 </span>|<span class="string"> 2        </span>|<span class="string"> DiscountPrice   </span>|<span class="string"> 45            </span>|</span><br><span class="line">當 計算活動折扣</span><br><span class="line">那麼 購物車商品折扣後為</span><br><span class="line">|<span class="string"> SalePageId </span>|<span class="string"> SaleProductSKUId </span>|<span class="string"> PromotionDiscount </span>|</span><br><span class="line">|<span class="string"> 50         </span>|<span class="string"> 50               </span>|<span class="string"> -12               </span>|</span><br><span class="line">|<span class="string"> 27         </span>|<span class="string"> 27               </span>|<span class="string"> -25               </span>|</span><br><span class="line">|<span class="string"> 26         </span>|<span class="string"> 26               </span>|<span class="string"> -19               </span>|</span><br><span class="line">|<span class="string"> 25         </span>|<span class="string"> 25               </span>|<span class="string"> 0                 </span>|</span><br></pre></td></tr></table></figure><h4 id="「人」寫的UAT"><a href="#「人」寫的UAT" class="headerlink" title="「人」寫的UAT"></a>「人」寫的UAT</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">場景: 商品有兩檔活動，全店活動與商品活動；</span><br><span class="line">．第一檔是全店活動 / 排除商品B；滿額打折，</span><br><span class="line">．折扣條件：滿10元，打95折 / 滿20元，打89折 / 滿30元，打84折</span><br><span class="line">．第二檔是指定商品；滿件折現，單階，指定商品A 、商品B</span><br><span class="line">．折扣條件：滿2件，折3元</span><br><span class="line"></span><br><span class="line">當 購物車中的商品為<span class="string">"商品A 與商品B"</span></span><br><span class="line">|<span class="string"> Title </span>|<span class="string"> SalePageId </span>|<span class="string"> SaleProductSKUId </span>|<span class="string"> Price </span>|<span class="string"> Qty </span>|</span><br><span class="line">|<span class="string"> 商品A   </span>|<span class="string"> 25         </span>|<span class="string"> 25               </span>|<span class="string"> 7.45  </span>|<span class="string"> 2   </span>|</span><br><span class="line">|<span class="string"> 商品B   </span>|<span class="string"> 26         </span>|<span class="string"> 26               </span>|<span class="string"> 4.45  </span>|<span class="string"> 2   </span>|</span><br><span class="line"></span><br><span class="line">並且 第<span class="string">"1"</span>檔是全店活動 ,排除以下商品</span><br><span class="line">    |<span class="string"> Title </span>|<span class="string"> SalePageId </span>|</span><br><span class="line">    |<span class="string"> 商品A   </span>|<span class="string"> 26         </span>|</span><br><span class="line"></span><br><span class="line">而且 第<span class="string">"1"</span>檔折扣條件是<span class="string">"滿額打折,滿10元，打95折 / 滿20元，打89折 / 滿30元，打84折"</span>,如下</span><br><span class="line">    |<span class="string"> Id </span>|<span class="string"> TypeDef      </span>|<span class="string"> TotalPrice </span>|<span class="string"> DiscountTypeDef </span>|<span class="string"> DiscountRate </span>|</span><br><span class="line">    |<span class="string"> 1  </span>|<span class="string"> TotalPriceV2 </span>|<span class="string"> 10         </span>|<span class="string"> DiscountRate    </span>|<span class="string"> 0.95         </span>|</span><br><span class="line">    |<span class="string"> 2  </span>|<span class="string"> TotalPriceV2 </span>|<span class="string"> 20         </span>|<span class="string"> DiscountRate    </span>|<span class="string"> 0.89         </span>|</span><br><span class="line">    |<span class="string"> 3  </span>|<span class="string"> TotalPriceV2 </span>|<span class="string"> 30         </span>|<span class="string"> DiscountRate    </span>|<span class="string"> 0.84         </span>|</span><br><span class="line"></span><br><span class="line">並且 第<span class="string">"2"</span>檔是指定商品,指定商品如下</span><br><span class="line">    |<span class="string"> Title </span>|<span class="string"> SalePageId </span>|</span><br><span class="line">    |<span class="string"> 商品A   </span>|<span class="string"> 25         </span>|</span><br><span class="line">    |<span class="string"> 商品B   </span>|<span class="string"> 26         </span>|</span><br><span class="line">    |<span class="string"> 商品C   </span>|<span class="string"> 27         </span>|</span><br><span class="line">    |<span class="string"> 商品D   </span>|<span class="string"> 50         </span>|</span><br><span class="line"></span><br><span class="line">而且 第<span class="string">"2"</span>檔折扣條件是<span class="string">"滿件折現,滿2件，折3元"</span>,如下</span><br><span class="line">    |<span class="string"> Id </span>|<span class="string"> TypeDef    </span>|<span class="string"> TotalQty </span>|<span class="string"> DiscountTypeDef </span>|<span class="string"> DiscountPrice </span>|</span><br><span class="line">    |<span class="string"> 4  </span>|<span class="string"> TotalQtyV2 </span>|<span class="string"> 2        </span>|<span class="string"> DiscountPrice   </span>|<span class="string"> 3             </span>|</span><br><span class="line"></span><br><span class="line">當 計算活動折扣</span><br><span class="line"></span><br><span class="line">那麼 購物車商品折扣金額及折扣後小計為 </span><br><span class="line">    |<span class="string"> Title </span>|<span class="string"> SalePageId </span>|<span class="string"> Price </span>|<span class="string"> Qty </span>|<span class="string"> PromotionDiscount </span>|<span class="string"> TotalPayment </span>|</span><br><span class="line">    |<span class="string"> 商品A   </span>|<span class="string"> 25         </span>|<span class="string"> 7.45  </span>|<span class="string"> 2   </span>|<span class="string"> -2.55             </span>|<span class="string"> 12.35        </span>|</span><br><span class="line">    |<span class="string"> 商品B   </span>|<span class="string"> 26         </span>|<span class="string"> 4.45  </span>|<span class="string"> 2   </span>|<span class="string"> -1.11             </span>|<span class="string"> 7.79         </span>|</span><br></pre></td></tr></table></figure><p>與 PM 及 QA 討論後 , 寫的 UAT 可閱讀性提高了<br>這裡用到了一些小技巧 , 讓 Cucumber 文件的可讀性更高<br>而不會有太多的重複方法 , 比如說把描述性的文字當作參數傳遞<br>實際上測試不會使用到這些變數 ,但是可以增加可讀性 .</p><h3 id="刪除台灣測試"><a href="#刪除台灣測試" class="headerlink" title="刪除台灣測試"></a>刪除台灣測試</h3><p>因為已經有了跨國所需要的測試 ,<br>台灣的測試便可以退場了.<br>實際上也不符合現況, 如多語系、時差與小數點等問題</p><h3 id="解析-CalculateShoppingCartPromotionDiscountV2Processor"><a href="#解析-CalculateShoppingCartPromotionDiscountV2Processor" class="headerlink" title="解析 CalculateShoppingCartPromotionDiscountV2Processor"></a>解析 <code>CalculateShoppingCartPromotionDiscountV2Processor</code></h3><p><img src="https://i.imgur.com/FioG5NG.jpg" alt=""></p><ol><li>無折扣的情境</li><li>新舊相容的情境</li><li>排序</li><li>計算折扣金額</li><li>看見相依<ol><li>程式碼中有 new 別的 class 的部份</li><li>程式碼中有使用靜態方法的部份</li></ol></li></ol><h3 id="補上單元測試"><a href="#補上單元測試" class="headerlink" title="補上單元測試"></a>補上單元測試</h3><p>最簡單的重構,就是將整個方法內的四個邏輯<br>拆成四塊個子方法,並為他們加上單元測試.<br>修改的過程,如果有紅燈就要修改成綠燈,<br>而整個成品要保證整合測試與單元測試都是綠燈. </p><p>此外,重構的過程中如果過到靜態方法,<br>或是 new 新物件, 都很有可能是種相依,<br>可以透過一些方法作解耦,<br>參考之前的文章<a href="/2017/04/23/unitestwriting/">單元測試這樣玩就對了</a> </p><h3 id="重構"><a href="#重構" class="headerlink" title="重構"></a>重構</h3><p>最後一步就是大膽的重構了,<br>有了測試作保護,<br>可以作更大範圍的重構,<br>如下圖示,這裡揭露了在台灣原有的繼承結構,<br>而紅色的部份是在跨國用不到的類別.<br><img src="https://i.imgur.com/VQ10wY6.jpg" alt=""></p><p>下一步，待續…</p><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;有幸參與了一個跨國的專案,&lt;br&gt;為了快速上線，決定將整套原本在台灣程式碼搬移到跨國專案上,&lt;br&gt;上線後再依使用者的需求調
      
    
    </summary>
    
    
      <category term="Unit Testing" scheme="http://blog.marsen.me/tags/Unit-Testing/"/>
    
      <category term="Integrated Testing" scheme="http://blog.marsen.me/tags/Integrated-Testing/"/>
    
  </entry>
  
  <entry>
    <title>20171023本周要聞/心得/學習擷錄</title>
    <link href="http://blog.marsen.me/2017/10/23/weekly_learn/20171023/"/>
    <id>http://blog.marsen.me/2017/10/23/weekly_learn/20171023/</id>
    <published>2017-10-23T03:47:27.000Z</published>
    <updated>2018-04-17T03:12:39.641Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><a href="https://mp.weixin.qq.com/s/n_Gnn5sJ0PkwhQhWUc0UeQ" target="_blank" rel="noopener">Docker 宣布拥抱 Kubernetes</a></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Docker Swarm与整个Docker平台紧密集成，然而并非所有人都愿意选择Swarm。 </span><br><span class="line">Hykes表示，默认的Swarm已经限制了Docker用户的完整体验，</span><br><span class="line">为此，Docker公司计划提供一个无缝平台，同时支持包含Swarm和Kubernetes集群的异构部署。</span><br><span class="line">Docker企业版（EE）将很快为Kuberenetes和Swarm提供全套Docker管理服务</span><br></pre></td></tr></table></figure></li><li><p>免費字哪裡找？使用<a href="https://fonts.google.com" target="_blank" rel="noopener">google font</a></p></li><li><p>使用TypeScript開發nodejs發生以下錯誤(使用gulp編譯成js)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error TS2693: &apos;Promise&apos; only refers to a type, but is being used as a value here.</span><br></pre></td></tr></table></figure><p> 安裝 <code>@types/es6-promise</code> 以解決問題</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev  @types/es6-promise</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>netstat -ano</code> 指令在 windows 上查詢佔用的 port 與 PID</p></li><li>執行 <code>npm ls moduleName</code> 可以列出目前專案所以相依該模組的模組</li><li>執行 <code>npm update</code> 更新目前專案的模組</li><li><code>package.json</code>裡面的的節點<code>dependencies</code>放的是與專案相關的模組，<br> 而<code>devDependencies</code>放的是與開發相關的模組。ex:<code>gulp</code>,<br>  請考慮你使用的模組，是為了開發？還是產品真的會用到。</li><li><p>想法</p><ul><li>懶人包應是協助跨越門檻與看見全貌的工具，<br>雖然難以避免代入個人的價值觀，但是刻意為之是不好的。</li><li>自我批判是一種建立反饋的最好方式，比起以公司\社群\世界最好的人要求自已，<br>以最好的自已去要求自已理應該最恰當的，錄影、看鏡子之類的方式… 。</li></ul></li><li><p>[叫人意想不到的激勵科學 (TED 中英文字幕)] (<a href="https://www.youtube.com/watch?v=rFVhkIrVDzM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=rFVhkIrVDzM</a>)</p><ol><li>自主性</li><li>掌握度</li><li>使命感</li></ol></li></ol><p>(fin)    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/n_Gnn5sJ0PkwhQhWUc0UeQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker 宣布拥抱 Kubernetes&lt;/a&gt;&lt;/p&gt;
 &lt;figu
      
    
    </summary>
    
    
      <category term="記錄" scheme="http://blog.marsen.me/tags/%E8%A8%98%E9%8C%84/"/>
    
      <category term="Kubernetes" scheme="http://blog.marsen.me/tags/Kubernetes/"/>
    
      <category term="Docker" scheme="http://blog.marsen.me/tags/Docker/"/>
    
      <category term="TypeScript" scheme="http://blog.marsen.me/tags/TypeScript/"/>
    
      <category term="Nodejs" scheme="http://blog.marsen.me/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>[閱讀筆記]異數</title>
    <link href="http://blog.marsen.me/2017/10/22/books/book_outliers_the_story_of_success/"/>
    <id>http://blog.marsen.me/2017/10/22/books/book_outliers_the_story_of_success/</id>
    <published>2017-10-22T09:10:46.000Z</published>
    <updated>2018-04-17T03:12:39.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="心得小結-2017-一讀"><a href="#心得小結-2017-一讀" class="headerlink" title="心得小結(2017.一讀)"></a>心得小結(2017.一讀)</h1><p>作者認為成功的主要原因是優勢的累績與努力，<br>我們常說時間花在哪裡，成就就在哪裡，<br>但是許多傑出的例子(莫札特與比爾。蓋茲)，<br>除了努力外，還有幸運的(?)際遇，<br>在很小的時候就開始邁向傑出，<br>這讓我想到福原愛;從小就接觸桌球又有母親(導師)親自調校，<br>但作者最終歸向時代與文化，兩個不可控的因素。<br>努力只能讓你成為比一般人好的人，<br>而加上際遇(時代與文化)，才能成為傑出(ex:世界前100之類)，<br>相比「我比別人更認真-刻意練習．讓自己發光」，<br><strong>我</strong>書比較強調導師與信念(熱情)的重要性，<br>而<strong>異數</strong>比較偏向命定論。</p><p>並沒有很推薦，但是書中的馬太效應，<br>以及透過學習別的語言來改變文化帶來的<strong>業</strong>，<br>值得反思 .</p><h1 id="筆記"><a href="#筆記" class="headerlink" title="筆記"></a>筆記</h1><h2 id="ch1-好上加好的馬太效應"><a href="#ch1-好上加好的馬太效應" class="headerlink" title="ch1 好上加好的馬太效應"></a>ch1 好上加好的馬太效應</h2><ol><li>成功是優勢的累積</li><li>我們把成功與個人特質畫上等號，其他人因而失去出頭的機會。<br>我們制定出來的規則反而壓抑成就，我們太早宣布某些人是失敗者。  </li></ol><h2 id="ch2-一萬個小時的努力"><a href="#ch2-一萬個小時的努力" class="headerlink" title="ch2 一萬個小時的努力"></a>ch2 一萬個小時的努力</h2><ol><li>他們的成功不完全是自已打造出來的，也是他們生長的時代造就的。</li></ol><h2 id="ch3-天才的迷思"><a href="#ch3-天才的迷思" class="headerlink" title="ch3 天才的迷思"></a>ch3 天才的迷思</h2><h2 id="ch4-天才的迷思．II"><a href="#ch4-天才的迷思．II" class="headerlink" title="ch4 天才的迷思．II"></a>ch4 天才的迷思．II</h2><ul><li>才智和成就沒有絕對關係</li><li>抽象智能與實用智能<ul><li>實用智能:社交常識與處事能力(後天習得，家庭)，知道在什麼時候用什麼方式以及說什麼，以達到最大效果</li></ul></li><li>階級的文化優勢<ul><li>勞動階級和貧窮人家的孩子，保守不信任別人，厭惡權威，拙於交際</li></ul></li></ul><p><em>feedback:</em> </p><ol><li>千里馬常有，伯樂不常有。</li><li>我是勞動階級和貧窮人家的孩子</li><li>人脈的重要性。</li><li>如何與權威人士交際？</li></ol><h2 id="ch5-猶太律師的啟示"><a href="#ch5-猶太律師的啟示" class="headerlink" title="ch5 猶太律師的啟示"></a>ch5 猶太律師的啟示</h2><ol><li>什麼都作，有生意上門就好了</li><li>機會其實是隱藏在逆境當中</li><li>你的父母是做什麼的，和你日後的成就大有關係</li><li>只要夠聰明就夠了</li></ol><p><em>feedback</em></p><ol><li><a href="https://www.evernote.com/shard/s36/sh/79c0d125-1dc3-4a7e-aa46-5264b223d29d/d8bcb5338bbbf4fe" target="_blank" rel="noopener">七年級最慘的是哪一年次？</a></li><li>生逢其時 vs 生不逢時</li></ol><h2 id="ch-6-以血還血"><a href="#ch-6-以血還血" class="headerlink" title="ch 6 以血還血"></a>ch 6 以血還血</h2><h2 id="ch-7-空中危機"><a href="#ch-7-空中危機" class="headerlink" title="ch 7 空中危機"></a>ch 7 空中危機</h2><ol><li>文化的影響</li><li>以大韓航空空難為例-文化的包袱</li><li>用語言改變文化的包袱(ex:英文)</li></ol><h2 id="ch-8-稻米文化與數學能力"><a href="#ch-8-稻米文化與數學能力" class="headerlink" title="ch 8 稻米文化與數學能力"></a>ch 8 稻米文化與數學能力</h2><h2 id="ch-9-知識力學校"><a href="#ch-9-知識力學校" class="headerlink" title="ch 9 知識力學校"></a>ch 9 知識力學校</h2><h2 id="後記-從牙買加到加拿大"><a href="#後記-從牙買加到加拿大" class="headerlink" title="後記 從牙買加到加拿大"></a>後記 從牙買加到加拿大</h2><ol><li>亞洲數字發音較有規則且合乎邏輯</li><li>成功者的共通點就是努力</li></ol><h2 id="書單"><a href="#書單" class="headerlink" title="書單"></a>書單</h2><ol><li>意外的百萬富翁(Jobs 傳記)</li></ol><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol><li>廖月娟的翻譯很不錯，感覺不出來是在讀外國人寫的書。</li><li><a href="https://www.mobile01.com/topicdetail.php?f=291&amp;t=5107472" target="_blank" rel="noopener">台灣財富排名690萬人是月光族230萬人有超3千萬資產</a></li></ol><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;心得小結-2017-一讀&quot;&gt;&lt;a href=&quot;#心得小結-2017-一讀&quot; class=&quot;headerlink&quot; title=&quot;心得小結(2017.一讀)&quot;&gt;&lt;/a&gt;心得小結(2017.一讀)&lt;/h1&gt;&lt;p&gt;作者認為成功的主要原因是優勢的累績與努力，&lt;br&gt;我們常
      
    
    </summary>
    
    
      <category term="閱讀筆記" scheme="http://blog.marsen.me/tags/%E9%96%B1%E8%AE%80%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>使用 DateInterceptor 攔截SQL 語法</title>
    <link href="http://blog.marsen.me/2017/09/24/sql_ef6_dateInterceptor/"/>
    <id>http://blog.marsen.me/2017/09/24/sql_ef6_dateInterceptor/</id>
    <published>2017-09-24T02:55:30.000Z</published>
    <updated>2018-04-17T03:12:39.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://blog.marsen.me/2017/09/18/sql_compatibility_level_with_datetime2/">SQL Compatibility Level 對MsSQL時間查詢的影響</a>這篇文章裡,<br>遇到了一個令難以處理的問題, 簡單的複述一下,  </p><ol><li>我的資料表以一個 datetime 欄位當作 PK</li><li>我的SQL DB版本為 2016 以上 (Compatibility Level預設值為130)</li></ol><p>這個時候我所有的 Entity Context 更新語法在呼叫 SaveChange 時會拋出錯誤;<br>原因在於 EF 所產生的 SQL Query 語法 , 會以 PK 值作為查詢條件,<br>而在這個時候 查詢時間的條件會精準到微秒(μs=1/1000000秒),<br>但是 datetime 欄位只會記錄到豪秒(ms=1/1000秒),<br>於是精準不足的部份就會補 0 ,<br>EX:<br><code>2017-09-24 11:55:35.3720000</code> 與 <code>2017-09-24 11:55:35.372</code><br>這會導致查無資料進而引發 <a href="https://msdn.microsoft.com/en-us/library/system.data.entity.infrastructure.dbupdateconcurrencyexception(v=vs.103" target="_blank" rel="noopener">dbupdateconcurrencyexception</a>.aspx)</p><h2 id="解決方針"><a href="#解決方針" class="headerlink" title="解決方針"></a>解決方針</h2><h3 id="修改資料欄位"><a href="#修改資料欄位" class="headerlink" title="修改資料欄位"></a>修改資料欄位</h3><p> 將資料庫的欄位datatype datetime 改成 datetime2 ,<br> 這或許是最理想的解法了, 你不需要更動程式碼,<br> 而且會提昇你資料的時間精準度.<br> 不過實務上,你必須考慮到你是否有dba的權限與即有的資料量,<br> 當產品的核心功能依賴著這張表的時候且有巨量資料存在時,<br> 更新欄位的資料型態的衝擊與風險或許是難以承受的.<br> 更不用說還要考慮到整個 DB Server Cluster 的架構之類的問題.</p><h3 id="修改-SQL-Server-Compatibility-Level-從-130-至-120"><a href="#修改-SQL-Server-Compatibility-Level-從-130-至-120" class="headerlink" title="修改 SQL Server Compatibility Level 從 130 至 120"></a>修改 SQL Server Compatibility Level 從 130 至 120</h3><p>非常不建議的作法, 除了要考慮上述權限、衝擊與風險的問題外,<br>如果降轉 Compatibility Level<br>或許會使得其他有使用到 datetime2 型態的資料欄位發生異常,<br>或是是失去原本精度的意義. </p><h3 id="使用-DateInterceptor-攔截SQL-語法"><a href="#使用-DateInterceptor-攔截SQL-語法" class="headerlink" title="使用 DateInterceptor 攔截SQL 語法"></a>使用 DateInterceptor 攔截SQL 語法</h3><p>在考量上述兩種情況, 為了不增加<del>DBA的工作量</del>無謂的風險與權責問題,<br>(其實是實務上我沒有DB Server的異動權限),<br>我們可以透過 <a href="https://msdn.microsoft.com/en-us/library/system.data.entity.infrastructure.interception.idbcommandinterceptor(v=vs.113" target="_blank" rel="noopener">IDbInterceptor</a>.aspx) 來欄截 Entity Framework 對DB 存取時執行的 Query</p><p>以下是個簡單的範例,</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DateInterceptor</span> : <span class="title">IDbInterceptor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReaderExecuting</span>(<span class="params">DbCommand command,</span></span></span><br><span class="line"><span class="function"><span class="params">        DbCommandInterceptionContext&lt;DbDataReader&gt; interceptionContext</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> dateParameters = command.Parameters.OfType&lt;DbParameter&gt;()</span><br><span class="line">            .Where(p =&gt; p.DbType == DbType.DateTime2);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> parameter <span class="keyword">in</span> dateParameters)</span><br><span class="line">        &#123;</span><br><span class="line">            parameter.DbType = DbType.DateTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們實作了一個 IDbInterceptor 的類別,<br>用來將 datetime2 的資料型別轉型成 datetime,<br>接下要將它掛載在 Entity Context之中 </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">EF6Entities</span> : <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EF6Entities</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params"><span class="string">"name=EF6Entities"</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DbInterception.Add(<span class="keyword">new</span> DateInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">DbModelBuilder modelBuilder</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnintentionalCodeFirstException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> DbSet&lt;BatchUploadData&gt; BatchUploadData &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一來就會以 datetime 的精準度產生 SQL Query</p><h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul><li><a href="https://github.com/marsen/EFDemo" target="_blank" rel="noopener">程式碼</a></li><li><a href="https://msdn.microsoft.com/en-us/library/system.data.entity.infrastructure.interception.idbcommandinterceptor.aspx" target="_blank" rel="noopener">IDbInterceptor</a></li><li><a href="https://msdn.microsoft.com/en-us/library/system.data.entity.infrastructure.interception.idbcommandinterceptor.aspx" target="_blank" rel="noopener">IDbCommandInterceptor</a></li><li><a href="https://stackoverflow.com/questions/46387565/how-to-change-how-entity-framework-generates-sql-precision-for-datetime" target="_blank" rel="noopener">How to change how Entity Framework generates SQL precision for Datetime</a></li></ul><p>(fin)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://blog.marsen.me/2017/09/18/sql_compatibility_level_wi
      
    
    </summary>
    
    
      <category term="Database" scheme="http://blog.marsen.me/tags/Database/"/>
    
      <category term="MsSQL" scheme="http://blog.marsen.me/tags/MsSQL/"/>
    
      <category term="Entity Framework" scheme="http://blog.marsen.me/tags/Entity-Framework/"/>
    
  </entry>
  
</feed>
